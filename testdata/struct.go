// Code generated by the codec package. DO NOT EDIT.

package codec

import (
	"reflect"

	"github.com/jba/codec/codecapi"
	foo "github.com/jba/codec/internal/testpkg"
)

//// codec.genStruct

var genStruct_type = reflect.TypeOf((*genStruct)(nil)).Elem()

type genStruct_codec struct {
	foo_T_codec *foo_T_codec
	fieldMap    []int
}

func (c *genStruct_codec) Fields() []string {
	return []string{"S", "B", "I", "I8", "I16", "I32", "I64", "F32", "F64", "U8", "U16", "U32", "U64", "C64", "C128", "BS", "T", "unexported"}
}

func (c *genStruct_codec) SetFieldMap(fm []int) {
	c.fieldMap = fm
}

func (c *genStruct_codec) TypesUsed() []reflect.Type {
	return []reflect.Type{foo_T_type}
}

func (c *genStruct_codec) SetCodecs(tcs []codecapi.TypeCodec) {
	c.foo_T_codec = tcs[0].(*foo_T_codec)
}

func (c *genStruct_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(genStruct)
	c.encode(e, &s)
}

func (c *genStruct_codec) encode(e *codecapi.Encoder, x *genStruct) {
	e.StartStruct()
	if x.S != "" {
		e.EncodeUint(0)
		e.EncodeString(x.S)
	}
	if x.B != false {
		e.EncodeUint(1)
		e.EncodeBool(x.B)
	}
	if x.I != 0 {
		e.EncodeUint(2)
		e.EncodeInt(int64(x.I))
	}
	if x.I8 != 0 {
		e.EncodeUint(3)
		e.EncodeByte(uint8(x.I8))
	}
	if x.I16 != 0 {
		e.EncodeUint(4)
		e.EncodeInt(int64(x.I16))
	}
	if x.I32 != 0 {
		e.EncodeUint(5)
		e.EncodeInt(int64(x.I32))
	}
	if x.I64 != 0 {
		e.EncodeUint(6)
		e.EncodeInt(x.I64)
	}
	if x.F32 != 0 {
		e.EncodeUint(7)
		e.EncodeFloat(float64(x.F32))
	}
	if x.F64 != 0 {
		e.EncodeUint(8)
		e.EncodeFloat(x.F64)
	}
	if x.U8 != 0 {
		e.EncodeUint(9)
		e.EncodeByte(x.U8)
	}
	if x.U16 != 0 {
		e.EncodeUint(10)
		e.EncodeUint(uint64(x.U16))
	}
	if x.U32 != 0 {
		e.EncodeUint(11)
		e.EncodeUint(uint64(x.U32))
	}
	if x.U64 != 0 {
		e.EncodeUint(12)
		e.EncodeUint(x.U64)
	}
	if x.C64 != 0 {
		e.EncodeUint(13)
		e.EncodeComplex(complex128(x.C64))
	}
	if x.C128 != 0 {
		e.EncodeUint(14)
		e.EncodeComplex(x.C128)
	}
	if x.BS != nil {
		e.EncodeUint(15)
		e.EncodeBytes(x.BS)
	}
	if x.T != nil {
		e.EncodeUint(16)
		c.foo_T_codec.encode(e, x.T)
	}
	if x.unexported != 0 {
		e.EncodeUint(17)
		e.EncodeInt(int64(x.unexported))
	}
	e.EndStruct()
}

func (c *genStruct_codec) Decode(d *codecapi.Decoder) interface{} {
	var x genStruct
	c.decode(d, &x)
	return x
}

func (c *genStruct_codec) decode(d *codecapi.Decoder, x *genStruct) {
	d.StartStruct()
loop:
	for {
		n := d.NextStructField(c.fieldMap)
		switch n {
		case 0:
			x.S = d.DecodeString()
		case 1:
			x.B = d.DecodeBool()
		case 2:
			x.I = int(d.DecodeInt())
		case 3:
			x.I8 = int8(d.DecodeByte())
		case 4:
			x.I16 = int16(d.DecodeInt())
		case 5:
			x.I32 = int32(d.DecodeInt())
		case 6:
			x.I64 = d.DecodeInt()
		case 7:
			x.F32 = float32(d.DecodeFloat())
		case 8:
			x.F64 = d.DecodeFloat()
		case 9:
			x.U8 = d.DecodeByte()
		case 10:
			x.U16 = uint16(d.DecodeUint())
		case 11:
			x.U32 = uint32(d.DecodeUint())
		case 12:
			x.U64 = d.DecodeUint()
		case 13:
			x.C64 = complex64(d.DecodeComplex())
		case 14:
			x.C128 = d.DecodeComplex()
		case 15:
			x.BS = d.DecodeBytes()
		case 16:
			c.foo_T_codec.decode(d, &x.T)
		case 17:
			x.unexported = int(d.DecodeInt())
		case -1:
			break loop
		case -2:
			d.UnknownField("genStruct")
		default:
			codecapi.Failf("bad struct field value: %d", n)
		}
	}
}

func init() {
	codecapi.Register(genStruct_type, func() codecapi.TypeCodec { return &genStruct_codec{} })
}

//// foo.T

var foo_T_type = reflect.TypeOf((*foo.T)(nil)).Elem()

type foo_T_codec struct {
	codecapi.NonStruct
}

func (c *foo_T_codec) TypesUsed() []reflect.Type      { return nil }
func (c *foo_T_codec) SetCodecs([]codecapi.TypeCodec) {}

func (c *foo_T_codec) Encode(e *codecapi.Encoder, x interface{}) { c.encode(e, x.(foo.T)) }

func (c *foo_T_codec) encode(e *codecapi.Encoder, s foo.T) {
	if s == nil {
		e.EncodeNil()
		return
	}
	e.StartList(len(s))
	for _, x := range s {
		e.EncodeInt(int64(x))
	}
}

func (c *foo_T_codec) Decode(d *codecapi.Decoder) interface{} {
	var x foo.T
	c.decode(d, &x)
	return x
}

func (c *foo_T_codec) decode(d *codecapi.Decoder, p *foo.T) {
	n := d.StartList()
	if n < 0 {
		return
	}
	s := make([]int, n)
	for i := 0; i < n; i++ {
		s[i] = int(d.DecodeInt())
	}
	*p = s
}

func init() {
	codecapi.Register(foo_T_type, func() codecapi.TypeCodec { return &foo_T_codec{} })
}
