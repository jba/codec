// Code generated by the codec package. DO NOT EDIT.

package codec

import (
	"github.com/jba/codec/codecapi"
	"github.com/jba/codec/internal/testpkg"
	"reflect"
)

// Fields of genStruct: S B I I8 I16 I32 I64 F32 F64 U8 U16 U32 U64 C64 C128 BS T unexported

type ptr_genStruct_codec struct {
	genStruct_codec *genStruct_codec
}

func (c *ptr_genStruct_codec) Init(tcs map[reflect.Type]codecapi.TypeCodec) {
	c.genStruct_codec = tcs[reflect.TypeOf((*genStruct)(nil)).Elem()].(*genStruct_codec)
}

func (c ptr_genStruct_codec) Fields() []string { return nil }

func (c ptr_genStruct_codec) Encode(e *codecapi.Encoder, x interface{}) { c.encode(e, x.(*genStruct)) }

func (c ptr_genStruct_codec) encode(e *codecapi.Encoder, x *genStruct) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(&genStruct_codec{}).encode(e, x)
}

func (c ptr_genStruct_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *genStruct
	c.decode(d, &x)
	return x
}

func (c ptr_genStruct_codec) decode(d *codecapi.Decoder, p **genStruct) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*genStruct)
		return
	}
	var x genStruct
	d.StoreRef(&x)
	c.genStruct_codec.decode(d, &x)
	*p = &x
}

type genStruct_codec struct {
	foo_T_codec *foo_T_codec
}

func (c *genStruct_codec) Init(tcs map[reflect.Type]codecapi.TypeCodec) {
	c.foo_T_codec = tcs[reflect.TypeOf((*foo.T)(nil)).Elem()].(*foo_T_codec)
}

func (c *genStruct_codec) Fields() []string {
	return []string{"S", "B", "I", "I8", "I16", "I32", "I64", "F32", "F64", "U8", "U16", "U32", "U64", "C64", "C128", "BS", "T", "unexported"}
}

func (c *genStruct_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(genStruct)
	c.encode(e, &s)
}

func (c *genStruct_codec) encode(e *codecapi.Encoder, x *genStruct) {
	e.StartStruct()
	if x.S != "" {
		e.EncodeUint(0)
		e.EncodeString(x.S)
	}
	if x.B != false {
		e.EncodeUint(1)
		e.EncodeBool(x.B)
	}
	if x.I != 0 {
		e.EncodeUint(2)
		e.EncodeInt(int64(x.I))
	}
	if x.I8 != 0 {
		e.EncodeUint(3)
		e.EncodeByte(uint8(x.I8))
	}
	if x.I16 != 0 {
		e.EncodeUint(4)
		e.EncodeInt(int64(x.I16))
	}
	if x.I32 != 0 {
		e.EncodeUint(5)
		e.EncodeInt(int64(x.I32))
	}
	if x.I64 != 0 {
		e.EncodeUint(6)
		e.EncodeInt(x.I64)
	}
	if x.F32 != 0 {
		e.EncodeUint(7)
		e.EncodeFloat(float64(x.F32))
	}
	if x.F64 != 0 {
		e.EncodeUint(8)
		e.EncodeFloat(x.F64)
	}
	if x.U8 != 0 {
		e.EncodeUint(9)
		e.EncodeByte(x.U8)
	}
	if x.U16 != 0 {
		e.EncodeUint(10)
		e.EncodeUint(uint64(x.U16))
	}
	if x.U32 != 0 {
		e.EncodeUint(11)
		e.EncodeUint(uint64(x.U32))
	}
	if x.U64 != 0 {
		e.EncodeUint(12)
		e.EncodeUint(x.U64)
	}
	if x.C64 != 0 {
		e.EncodeUint(13)
		e.EncodeComplex(complex128(x.C64))
	}
	if x.C128 != 0 {
		e.EncodeUint(14)
		e.EncodeComplex(x.C128)
	}
	if x.BS != nil {
		e.EncodeUint(15)
		e.EncodeBytes(x.BS)
	}
	if x.T != nil {
		e.EncodeUint(16)
		(&foo_T_codec{}).encode(e, foo.T(x.T))
	}
	if x.unexported != 0 {
		e.EncodeUint(17)
		e.EncodeInt(int64(x.unexported))
	}
	e.EndStruct()
}

func (c *genStruct_codec) Decode(d *codecapi.Decoder) interface{} {
	var x genStruct
	c.decode(d, &x)
	return x
}

func (c *genStruct_codec) decode(d *codecapi.Decoder, x *genStruct) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.S = d.DecodeString()
		case 1:
			x.B = d.DecodeBool()
		case 2:
			x.I = int(d.DecodeInt())
		case 3:
			x.I8 = int8(d.DecodeByte())
		case 4:
			x.I16 = int16(d.DecodeInt())
		case 5:
			x.I32 = int32(d.DecodeInt())
		case 6:
			x.I64 = d.DecodeInt()
		case 7:
			x.F32 = float32(d.DecodeFloat())
		case 8:
			x.F64 = d.DecodeFloat()
		case 9:
			x.U8 = d.DecodeByte()
		case 10:
			x.U16 = uint16(d.DecodeUint())
		case 11:
			x.U32 = uint32(d.DecodeUint())
		case 12:
			x.U64 = d.DecodeUint()
		case 13:
			x.C64 = complex64(d.DecodeComplex())
		case 14:
			x.C128 = d.DecodeComplex()
		case 15:
			x.BS = d.DecodeBytes()
		case 16:
			c.foo_T_codec.decode(d, &x.T)
		case 17:
			x.unexported = int(d.DecodeInt())
		default:
			d.UnknownField("genStruct", n)
		}
	}
}

func init() {
	codecapi.Register(genStruct{}, func() codecapi.TypeCodec { return &genStruct_codec{} })
	codecapi.Register(&genStruct{}, func() codecapi.TypeCodec { return &ptr_genStruct_codec{} })
}

type foo_T_codec struct {
}

func (c *foo_T_codec) Init(tcs map[reflect.Type]codecapi.TypeCodec) {

}

func (c *foo_T_codec) Fields() []string { return nil }

func (c *foo_T_codec) Encode(e *codecapi.Encoder, x interface{}) { c.encode(e, x.(foo.T)) }

func (c *foo_T_codec) encode(e *codecapi.Encoder, s foo.T) {
	if s == nil {
		e.EncodeNil()
		return
	}
	e.StartList(len(s))
	for _, x := range s {
		e.EncodeInt(int64(x))
	}
}

func (c *foo_T_codec) Decode(d *codecapi.Decoder) interface{} {
	var x foo.T
	c.decode(d, &x)
	return x
}

func (c *foo_T_codec) decode(d *codecapi.Decoder, p *foo.T) {
	n := d.StartList()
	if n < 0 {
		return
	}
	s := make([]int, n)
	for i := 0; i < n; i++ {
		s[i] = int(d.DecodeInt())
	}
	*p = s
}

func init() {
	codecapi.Register(foo.T(nil), func() codecapi.TypeCodec { return &foo_T_codec{} })
}
