// Code generated by the codec package. DO NOT EDIT.

package codec

import (
	"reflect"

	"github.com/jba/codec/codecapi"
)

var map_string_bool_type = reflect.TypeOf((*map[string]bool)(nil)).Elem()

type map_string_bool_codec struct {
}

func (c *map_string_bool_codec) Init(tcs map[reflect.Type]codecapi.TypeCodec, _ []int) {
}

func (c *map_string_bool_codec) Fields() []string { return nil }

func (c *map_string_bool_codec) TypesUsed() []reflect.Type {
	var types []reflect.Type

	return types
}

func (c *map_string_bool_codec) CodecsUsed([]codecapi.TypeCodec) {}

func (c *map_string_bool_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(map[string]bool))
}

func (c *map_string_bool_codec) encode(e *codecapi.Encoder, m map[string]bool) {
	if m == nil {
		e.EncodeNil()
		return
	}
	e.StartList(2 * len(m))
	for k, v := range m {
		e.EncodeString(k)
		e.EncodeBool(v)
	}
}

func (c *map_string_bool_codec) Decode(d *codecapi.Decoder) interface{} {
	var x map[string]bool
	c.decode(d, &x)
	return x
}

func (c *map_string_bool_codec) decode(d *codecapi.Decoder, p *map[string]bool) {
	n2 := d.StartList()
	if n2 < 0 {
		return
	}
	n := n2 / 2
	m := make(map[string]bool, n)
	var k string
	var v bool
	for i := 0; i < n; i++ {
		k = d.DecodeString()
		v = d.DecodeBool()
		m[k] = v
	}
	*p = m
}

func init() {
	codecapi.Register(map[string]bool(nil), func() codecapi.TypeCodec { return &map_string_bool_codec{} })
}
