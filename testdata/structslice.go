// Code generated by the codec package. DO NOT EDIT.

package codec

import (
	"reflect"

	"github.com/jba/codec/codecapi"
)

//// []codec.smallStruct

var slice_smallStruct_type = reflect.TypeOf((*[]smallStruct)(nil)).Elem()

type slice_smallStruct_codec struct {
	codecapi.NonStruct

	smallStruct_codec *smallStruct_codec
}

func (c *slice_smallStruct_codec) TypesUsed() []reflect.Type {
	return []reflect.Type{smallStruct_type}
}

func (c *slice_smallStruct_codec) SetCodecs(tcs []codecapi.TypeCodec) {
	c.smallStruct_codec = tcs[0].(*smallStruct_codec)
}

func (c *slice_smallStruct_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.([]smallStruct))
}

func (c *slice_smallStruct_codec) encode(e *codecapi.Encoder, s []smallStruct) {
	if s == nil {
		e.EncodeNil()
		return
	}
	e.StartList(len(s))
	for _, x := range s {
		c.smallStruct_codec.encode(e, &x)
	}
}

func (c *slice_smallStruct_codec) Decode(d *codecapi.Decoder) interface{} {
	var x []smallStruct
	c.decode(d, &x)
	return x
}

func (c *slice_smallStruct_codec) decode(d *codecapi.Decoder, p *[]smallStruct) {
	n := d.StartList()
	if n < 0 {
		return
	}
	s := make([]smallStruct, n)
	for i := 0; i < n; i++ {
		c.smallStruct_codec.decode(d, &s[i])
	}
	*p = s
}

func init() {
	codecapi.Register(slice_smallStruct_type, func() codecapi.TypeCodec { return &slice_smallStruct_codec{} })
}

//// codec.smallStruct

var smallStruct_type = reflect.TypeOf((*smallStruct)(nil)).Elem()

type smallStruct_codec struct {
	fieldMap []int
}

func (c *smallStruct_codec) Fields() []string {
	return []string{"X"}
}

func (c *smallStruct_codec) SetFieldMap(fm []int) {
	c.fieldMap = fm
}

func (c *smallStruct_codec) TypesUsed() []reflect.Type {
	return []reflect.Type{}
}

func (c *smallStruct_codec) SetCodecs(tcs []codecapi.TypeCodec) {
}

func (c *smallStruct_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(smallStruct)
	c.encode(e, &s)
}

func (c *smallStruct_codec) encode(e *codecapi.Encoder, x *smallStruct) {
	e.StartStruct()
	if x.X != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.X))
	}
	e.EndStruct()
}

func (c *smallStruct_codec) Decode(d *codecapi.Decoder) interface{} {
	var x smallStruct
	c.decode(d, &x)
	return x
}

func (c *smallStruct_codec) decode(d *codecapi.Decoder, x *smallStruct) {
	d.StartStruct()
	for {
		n := d.NextStructField(c.fieldMap)
		if n == -1 {
			break
		}
		switch n {
		case 0:
			x.X = int(d.DecodeInt())
		default:
			d.UnknownField("smallStruct", n)
		}
	}
}

func init() {
	codecapi.Register(smallStruct_type, func() codecapi.TypeCodec { return &smallStruct_codec{} })
}
