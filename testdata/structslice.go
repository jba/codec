// Code generated by the codec package. DO NOT EDIT.

package codec

import (
	"github.com/jba/codec/codecapi"
	"reflect"
)

type slice_smallStruct_codec struct {
	smallStruct_codec *smallStruct_codec
}

func (c *slice_smallStruct_codec) Init(tcs map[reflect.Type]codecapi.TypeCodec) {
	c.smallStruct_codec = tcs[reflect.TypeOf((*smallStruct)(nil)).Elem()].(*smallStruct_codec)

}

func (c *slice_smallStruct_codec) Fields() []string { return nil }

func (c *slice_smallStruct_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.([]smallStruct))
}

func (c *slice_smallStruct_codec) encode(e *codecapi.Encoder, s []smallStruct) {
	if s == nil {
		e.EncodeNil()
		return
	}
	e.StartList(len(s))
	for _, x := range s {
		(&smallStruct_codec{}).encode(e, &x)
	}
}

func (c *slice_smallStruct_codec) Decode(d *codecapi.Decoder) interface{} {
	var x []smallStruct
	c.decode(d, &x)
	return x
}

func (c *slice_smallStruct_codec) decode(d *codecapi.Decoder, p *[]smallStruct) {
	n := d.StartList()
	if n < 0 {
		return
	}
	s := make([]smallStruct, n)
	for i := 0; i < n; i++ {
		c.smallStruct_codec.decode(d, &s[i])
	}
	*p = s
}

func init() {
	codecapi.Register([]smallStruct(nil), func() codecapi.TypeCodec { return &slice_smallStruct_codec{} })
}

// Fields of smallStruct: X

type ptr_smallStruct_codec struct {
	smallStruct_codec *smallStruct_codec
}

func (c *ptr_smallStruct_codec) Init(tcs map[reflect.Type]codecapi.TypeCodec) {
	c.smallStruct_codec = tcs[reflect.TypeOf((*smallStruct)(nil)).Elem()].(*smallStruct_codec)
}

func (c ptr_smallStruct_codec) Fields() []string { return nil }

func (c ptr_smallStruct_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*smallStruct))
}

func (c ptr_smallStruct_codec) encode(e *codecapi.Encoder, x *smallStruct) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(&smallStruct_codec{}).encode(e, x)
}

func (c ptr_smallStruct_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *smallStruct
	c.decode(d, &x)
	return x
}

func (c ptr_smallStruct_codec) decode(d *codecapi.Decoder, p **smallStruct) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*smallStruct)
		return
	}
	var x smallStruct
	d.StoreRef(&x)
	c.smallStruct_codec.decode(d, &x)
	*p = &x
}

type smallStruct_codec struct {
}

func (c *smallStruct_codec) Init(tcs map[reflect.Type]codecapi.TypeCodec) {
}

func (c *smallStruct_codec) Fields() []string {
	return []string{"X"}
}

func (c *smallStruct_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(smallStruct)
	c.encode(e, &s)
}

func (c *smallStruct_codec) encode(e *codecapi.Encoder, x *smallStruct) {
	e.StartStruct()
	if x.X != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.X))
	}
	e.EndStruct()
}

func (c *smallStruct_codec) Decode(d *codecapi.Decoder) interface{} {
	var x smallStruct
	c.decode(d, &x)
	return x
}

func (c *smallStruct_codec) decode(d *codecapi.Decoder, x *smallStruct) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.X = int(d.DecodeInt())
		default:
			d.UnknownField("smallStruct", n)
		}
	}
}

func init() {
	codecapi.Register(smallStruct{}, func() codecapi.TypeCodec { return &smallStruct_codec{} })
	codecapi.Register(&smallStruct{}, func() codecapi.TypeCodec { return &ptr_smallStruct_codec{} })
}
