// Code generated by the codec package. DO NOT EDIT.

package codec

import (
	"go/token"
	"net"
	"reflect"
	"time"

	"github.com/jba/codec/codecapi"
	foo "github.com/jba/codec/internal/testpkg"
)

// Fields of node: Value Next

var ptr_node_type = reflect.TypeOf((*node)(nil))

type ptr_node_codec struct {
	node_codec *node_codec
}

func (c *ptr_node_codec) Init(tcs map[reflect.Type]codecapi.TypeCodec, _ []int) {
	c.node_codec = tcs[reflect.TypeOf((*node)(nil)).Elem()].(*node_codec)
}

func (c ptr_node_codec) Fields() []string { return nil }

func (c ptr_node_codec) TypesUsed() []reflect.Type { return []reflect.Type{node_type} }

func (c ptr_node_codec) Encode(e *codecapi.Encoder, x interface{}) { c.encode(e, x.(*node)) }

func (c ptr_node_codec) encode(e *codecapi.Encoder, x *node) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(&node_codec{}).encode(e, x)
}

func (c ptr_node_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *node
	c.decode(d, &x)
	return x
}

func (c ptr_node_codec) decode(d *codecapi.Decoder, p **node) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*node)
		return
	}
	var x node
	d.StoreRef(&x)
	c.node_codec.decode(d, &x)
	*p = &x
}

var node_type = ptr_node_type.Elem()

type node_codec struct {
	ptr_node_codec *ptr_node_codec
	fieldMap       []int
}

func (c *node_codec) Init(tcs map[reflect.Type]codecapi.TypeCodec, fieldMap []int) {
	c.ptr_node_codec = tcs[reflect.TypeOf((**node)(nil)).Elem()].(*ptr_node_codec)
	c.fieldMap = fieldMap
}

func (c *node_codec) Fields() []string {
	return []string{"Value", "Next"}
}

func (c *node_codec) TypesUsed() []reflect.Type {
	return []reflect.Type{ptr_node_type}
}

func (c *node_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(node)
	c.encode(e, &s)
}

func (c *node_codec) encode(e *codecapi.Encoder, x *node) {
	e.StartStruct()
	if x.Value != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.Value))
	}
	if x.Next != nil {
		e.EncodeUint(1)
		(&ptr_node_codec{}).encode(e, x.Next)
	}
	e.EndStruct()
}

func (c *node_codec) Decode(d *codecapi.Decoder) interface{} {
	var x node
	c.decode(d, &x)
	return x
}

func (c *node_codec) decode(d *codecapi.Decoder, x *node) {
	d.StartStruct()
	for {
		n := d.NextStructField(c.fieldMap)
		if n == -1 {
			break
		}
		switch n {
		case 0:
			x.Value = int(d.DecodeInt())
		case 1:
			c.ptr_node_codec.decode(d, &x.Next)
		default:
			d.UnknownField("node", n)
		}
	}
}

func init() {
	codecapi.Register(node{}, func() codecapi.TypeCodec { return &node_codec{} })
	codecapi.Register(&node{}, func() codecapi.TypeCodec { return &ptr_node_codec{} })
}

var array_1_structType_type = reflect.TypeOf((*[1]structType)(nil)).Elem()

type array_1_structType_codec struct {
	structType_codec *structType_codec
}

func (c *array_1_structType_codec) Init(tcs map[reflect.Type]codecapi.TypeCodec, _ []int) {
	c.structType_codec = tcs[reflect.TypeOf((*structType)(nil)).Elem()].(*structType_codec)

}

func (c *array_1_structType_codec) Fields() []string { return nil }

func (c *array_1_structType_codec) TypesUsed() []reflect.Type {
	return []reflect.Type{structType_type}
}

func (c *array_1_structType_codec) Encode(e *codecapi.Encoder, x interface{}) {
	a := x.([1]structType)
	c.encode(e, &a)
}

func (c *array_1_structType_codec) encode(e *codecapi.Encoder, s *[1]structType) {
	(&slice_structType_codec{}).encode(e, (*s)[:])
}

func (c *array_1_structType_codec) Decode(d *codecapi.Decoder) interface{} {
	var x [1]structType
	c.decode(d, &x)
	return x
}

func (c *array_1_structType_codec) decode(d *codecapi.Decoder, p *[1]structType) {
	n := d.StartList()
	if n < 0 {
		return
	}
	if n != 1 {
		codecapi.Failf("array size mismatch: got %d, want 1", n)
	}
	for i := 0; i < n; i++ {
		c.structType_codec.decode(d, &(*p)[i])
	}
}

func init() {
	codecapi.Register([1]structType{}, func() codecapi.TypeCodec { return &array_1_structType_codec{} })
}

var array_1_int_type = reflect.TypeOf((*[1]int)(nil)).Elem()

type array_1_int_codec struct {
}

func (c *array_1_int_codec) Init(tcs map[reflect.Type]codecapi.TypeCodec, _ []int) {

}

func (c *array_1_int_codec) Fields() []string { return nil }

func (c *array_1_int_codec) TypesUsed() []reflect.Type {
	return nil
}

func (c *array_1_int_codec) Encode(e *codecapi.Encoder, x interface{}) {
	a := x.([1]int)
	c.encode(e, &a)
}

func (c *array_1_int_codec) encode(e *codecapi.Encoder, s *[1]int) {
	(&slice_int_codec{}).encode(e, (*s)[:])
}

func (c *array_1_int_codec) Decode(d *codecapi.Decoder) interface{} {
	var x [1]int
	c.decode(d, &x)
	return x
}

func (c *array_1_int_codec) decode(d *codecapi.Decoder, p *[1]int) {
	n := d.StartList()
	if n < 0 {
		return
	}
	if n != 1 {
		codecapi.Failf("array size mismatch: got %d, want 1", n)
	}
	for i := 0; i < n; i++ {
		(*p)[i] = int(d.DecodeInt())
	}
}

func init() {
	codecapi.Register([1]int{}, func() codecapi.TypeCodec { return &array_1_int_codec{} })
}

var slice_structType_type = reflect.TypeOf((*[]structType)(nil)).Elem()

type slice_structType_codec struct {
	structType_codec *structType_codec
}

func (c *slice_structType_codec) Init(tcs map[reflect.Type]codecapi.TypeCodec, _ []int) {
	c.structType_codec = tcs[reflect.TypeOf((*structType)(nil)).Elem()].(*structType_codec)

}

func (c *slice_structType_codec) Fields() []string { return nil }

func (c *slice_structType_codec) TypesUsed() []reflect.Type {
	return []reflect.Type{structType_type}
}

func (c *slice_structType_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.([]structType))
}

func (c *slice_structType_codec) encode(e *codecapi.Encoder, s []structType) {
	if s == nil {
		e.EncodeNil()
		return
	}
	e.StartList(len(s))
	for _, x := range s {
		(&structType_codec{}).encode(e, &x)
	}
}

func (c *slice_structType_codec) Decode(d *codecapi.Decoder) interface{} {
	var x []structType
	c.decode(d, &x)
	return x
}

func (c *slice_structType_codec) decode(d *codecapi.Decoder, p *[]structType) {
	n := d.StartList()
	if n < 0 {
		return
	}
	s := make([]structType, n)
	for i := 0; i < n; i++ {
		c.structType_codec.decode(d, &s[i])
	}
	*p = s
}

func init() {
	codecapi.Register([]structType(nil), func() codecapi.TypeCodec { return &slice_structType_codec{} })
}

var slice_int_type = reflect.TypeOf((*[]int)(nil)).Elem()

type slice_int_codec struct {
}

func (c *slice_int_codec) Init(tcs map[reflect.Type]codecapi.TypeCodec, _ []int) {

}

func (c *slice_int_codec) Fields() []string { return nil }

func (c *slice_int_codec) TypesUsed() []reflect.Type {
	return nil
}

func (c *slice_int_codec) Encode(e *codecapi.Encoder, x interface{}) { c.encode(e, x.([]int)) }

func (c *slice_int_codec) encode(e *codecapi.Encoder, s []int) {
	if s == nil {
		e.EncodeNil()
		return
	}
	e.StartList(len(s))
	for _, x := range s {
		e.EncodeInt(int64(x))
	}
}

func (c *slice_int_codec) Decode(d *codecapi.Decoder) interface{} {
	var x []int
	c.decode(d, &x)
	return x
}

func (c *slice_int_codec) decode(d *codecapi.Decoder, p *[]int) {
	n := d.StartList()
	if n < 0 {
		return
	}
	s := make([]int, n)
	for i := 0; i < n; i++ {
		s[i] = int(d.DecodeInt())
	}
	*p = s
}

func init() {
	codecapi.Register([]int(nil), func() codecapi.TypeCodec { return &slice_int_codec{} })
}

var definedArray_type = reflect.TypeOf((*definedArray)(nil)).Elem()

type definedArray_codec struct {
}

func (c *definedArray_codec) Init(tcs map[reflect.Type]codecapi.TypeCodec, _ []int) {

}

func (c *definedArray_codec) Fields() []string { return nil }

func (c *definedArray_codec) TypesUsed() []reflect.Type {
	return nil
}

func (c *definedArray_codec) Encode(e *codecapi.Encoder, x interface{}) {
	a := x.(definedArray)
	c.encode(e, &a)
}

func (c *definedArray_codec) encode(e *codecapi.Encoder, s *definedArray) {
	(&slice_int_codec{}).encode(e, (*s)[:])
}

func (c *definedArray_codec) Decode(d *codecapi.Decoder) interface{} {
	var x definedArray
	c.decode(d, &x)
	return x
}

func (c *definedArray_codec) decode(d *codecapi.Decoder, p *definedArray) {
	n := d.StartList()
	if n < 0 {
		return
	}
	if n != 1 {
		codecapi.Failf("array size mismatch: got %d, want 1", n)
	}
	for i := 0; i < n; i++ {
		(*p)[i] = int(d.DecodeInt())
	}
}

func init() {
	codecapi.Register(definedArray{}, func() codecapi.TypeCodec { return &definedArray_codec{} })
}

var definedMap_type = reflect.TypeOf((*definedMap)(nil)).Elem()

type definedMap_codec struct {
}

func (c *definedMap_codec) Init(tcs map[reflect.Type]codecapi.TypeCodec, _ []int) {
}

func (c *definedMap_codec) Fields() []string { return nil }

func (c *definedMap_codec) TypesUsed() []reflect.Type {
	var types []reflect.Type

	return types
}

func (c *definedMap_codec) Encode(e *codecapi.Encoder, x interface{}) { c.encode(e, x.(definedMap)) }

func (c *definedMap_codec) encode(e *codecapi.Encoder, m definedMap) {
	if m == nil {
		e.EncodeNil()
		return
	}
	e.StartList(2 * len(m))
	for k, v := range m {
		e.EncodeString(k)
		e.EncodeBool(v)
	}
}

func (c *definedMap_codec) Decode(d *codecapi.Decoder) interface{} {
	var x definedMap
	c.decode(d, &x)
	return x
}

func (c *definedMap_codec) decode(d *codecapi.Decoder, p *definedMap) {
	n2 := d.StartList()
	if n2 < 0 {
		return
	}
	n := n2 / 2
	m := make(definedMap, n)
	var k string
	var v bool
	for i := 0; i < n; i++ {
		k = d.DecodeString()
		v = d.DecodeBool()
		m[k] = v
	}
	*p = m
}

func init() {
	codecapi.Register(definedMap(nil), func() codecapi.TypeCodec { return &definedMap_codec{} })
}

var definedSlice_type = reflect.TypeOf((*definedSlice)(nil)).Elem()

type definedSlice_codec struct {
}

func (c *definedSlice_codec) Init(tcs map[reflect.Type]codecapi.TypeCodec, _ []int) {

}

func (c *definedSlice_codec) Fields() []string { return nil }

func (c *definedSlice_codec) TypesUsed() []reflect.Type {
	return nil
}

func (c *definedSlice_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(definedSlice))
}

func (c *definedSlice_codec) encode(e *codecapi.Encoder, s definedSlice) {
	if s == nil {
		e.EncodeNil()
		return
	}
	e.StartList(len(s))
	for _, x := range s {
		e.EncodeInt(int64(x))
	}
}

func (c *definedSlice_codec) Decode(d *codecapi.Decoder) interface{} {
	var x definedSlice
	c.decode(d, &x)
	return x
}

func (c *definedSlice_codec) decode(d *codecapi.Decoder, p *definedSlice) {
	n := d.StartList()
	if n < 0 {
		return
	}
	s := make([]int, n)
	for i := 0; i < n; i++ {
		s[i] = int(d.DecodeInt())
	}
	*p = s
}

func init() {
	codecapi.Register(definedSlice(nil), func() codecapi.TypeCodec { return &definedSlice_codec{} })
}

// Fields of generatedTestTypes: Node Slice Array Map Struct Time IP StructSlice StructArray StructMap DefSlice DefArray DefMap Pos T

var ptr_generatedTestTypes_type = reflect.TypeOf((*generatedTestTypes)(nil))

type ptr_generatedTestTypes_codec struct {
	generatedTestTypes_codec *generatedTestTypes_codec
}

func (c *ptr_generatedTestTypes_codec) Init(tcs map[reflect.Type]codecapi.TypeCodec, _ []int) {
	c.generatedTestTypes_codec = tcs[reflect.TypeOf((*generatedTestTypes)(nil)).Elem()].(*generatedTestTypes_codec)
}

func (c ptr_generatedTestTypes_codec) Fields() []string { return nil }

func (c ptr_generatedTestTypes_codec) TypesUsed() []reflect.Type {
	return []reflect.Type{generatedTestTypes_type}
}

func (c ptr_generatedTestTypes_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*generatedTestTypes))
}

func (c ptr_generatedTestTypes_codec) encode(e *codecapi.Encoder, x *generatedTestTypes) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(&generatedTestTypes_codec{}).encode(e, x)
}

func (c ptr_generatedTestTypes_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *generatedTestTypes
	c.decode(d, &x)
	return x
}

func (c ptr_generatedTestTypes_codec) decode(d *codecapi.Decoder, p **generatedTestTypes) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*generatedTestTypes)
		return
	}
	var x generatedTestTypes
	d.StoreRef(&x)
	c.generatedTestTypes_codec.decode(d, &x)
	*p = &x
}

var generatedTestTypes_type = ptr_generatedTestTypes_type.Elem()

type generatedTestTypes_codec struct {
	ptr_node_codec              *ptr_node_codec
	array_1_structType_codec    *array_1_structType_codec
	array_1_int_codec           *array_1_int_codec
	slice_structType_codec      *slice_structType_codec
	slice_int_codec             *slice_int_codec
	definedArray_codec          *definedArray_codec
	definedMap_codec            *definedMap_codec
	definedSlice_codec          *definedSlice_codec
	structType_codec            *structType_codec
	foo_T_codec                 *foo_T_codec
	map__1_int_structType_codec *map__1_int_structType_codec
	map_string_bool_codec       *map_string_bool_codec
	time_Time_codec             *time_Time_codec
	fieldMap                    []int
}

func (c *generatedTestTypes_codec) Init(tcs map[reflect.Type]codecapi.TypeCodec, fieldMap []int) {
	c.ptr_node_codec = tcs[reflect.TypeOf((**node)(nil)).Elem()].(*ptr_node_codec)
	c.array_1_structType_codec = tcs[reflect.TypeOf((*[1]structType)(nil)).Elem()].(*array_1_structType_codec)
	c.array_1_int_codec = tcs[reflect.TypeOf((*[1]int)(nil)).Elem()].(*array_1_int_codec)
	c.slice_structType_codec = tcs[reflect.TypeOf((*[]structType)(nil)).Elem()].(*slice_structType_codec)
	c.slice_int_codec = tcs[reflect.TypeOf((*[]int)(nil)).Elem()].(*slice_int_codec)
	c.definedArray_codec = tcs[reflect.TypeOf((*definedArray)(nil)).Elem()].(*definedArray_codec)
	c.definedMap_codec = tcs[reflect.TypeOf((*definedMap)(nil)).Elem()].(*definedMap_codec)
	c.definedSlice_codec = tcs[reflect.TypeOf((*definedSlice)(nil)).Elem()].(*definedSlice_codec)
	c.structType_codec = tcs[reflect.TypeOf((*structType)(nil)).Elem()].(*structType_codec)
	c.foo_T_codec = tcs[reflect.TypeOf((*foo.T)(nil)).Elem()].(*foo_T_codec)
	c.map__1_int_structType_codec = tcs[reflect.TypeOf((*map[[1]int]structType)(nil)).Elem()].(*map__1_int_structType_codec)
	c.map_string_bool_codec = tcs[reflect.TypeOf((*map[string]bool)(nil)).Elem()].(*map_string_bool_codec)
	c.time_Time_codec = tcs[reflect.TypeOf((*time.Time)(nil)).Elem()].(*time_Time_codec)
	c.fieldMap = fieldMap
}

func (c *generatedTestTypes_codec) Fields() []string {
	return []string{"Node", "Slice", "Array", "Map", "Struct", "Time", "IP", "StructSlice", "StructArray", "StructMap", "DefSlice", "DefArray", "DefMap", "Pos", "T"}
}

func (c *generatedTestTypes_codec) TypesUsed() []reflect.Type {
	return []reflect.Type{ptr_node_type, array_1_structType_type, array_1_int_type, slice_structType_type, slice_int_type, definedArray_type, definedMap_type, definedSlice_type, structType_type, foo_T_type, map__1_int_structType_type, map_string_bool_type, time_Time_type}
}

func (c *generatedTestTypes_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(generatedTestTypes)
	c.encode(e, &s)
}

func (c *generatedTestTypes_codec) encode(e *codecapi.Encoder, x *generatedTestTypes) {
	e.StartStruct()
	if x.Node != nil {
		e.EncodeUint(0)
		(&ptr_node_codec{}).encode(e, x.Node)
	}
	if x.Slice != nil {
		e.EncodeUint(1)
		(&slice_int_codec{}).encode(e, x.Slice)
	}

	e.EncodeUint(2)
	(&array_1_int_codec{}).encode(e, &x.Array)
	if x.Map != nil {
		e.EncodeUint(3)
		(&map_string_bool_codec{}).encode(e, x.Map)
	}

	e.EncodeUint(4)
	(&structType_codec{}).encode(e, &x.Struct)

	e.EncodeUint(5)
	(&time_Time_codec{}).encode(e, x.Time)
	if x.IP != nil {
		e.EncodeUint(6)
		e.EncodeBytes([]uint8(x.IP))
	}
	if x.StructSlice != nil {
		e.EncodeUint(7)
		(&slice_structType_codec{}).encode(e, x.StructSlice)
	}

	e.EncodeUint(8)
	(&array_1_structType_codec{}).encode(e, &x.StructArray)
	if x.StructMap != nil {
		e.EncodeUint(9)
		(&map__1_int_structType_codec{}).encode(e, x.StructMap)
	}
	if x.DefSlice != nil {
		e.EncodeUint(10)
		(&definedSlice_codec{}).encode(e, definedSlice(x.DefSlice))
	}

	e.EncodeUint(11)
	(&definedArray_codec{}).encode(e, &x.DefArray)
	if x.DefMap != nil {
		e.EncodeUint(12)
		(&definedMap_codec{}).encode(e, definedMap(x.DefMap))
	}
	if x.Pos != 0 {
		e.EncodeUint(13)
		e.EncodeInt(int64(x.Pos))
	}
	if x.T != nil {
		e.EncodeUint(14)
		(&foo_T_codec{}).encode(e, foo.T(x.T))
	}
	e.EndStruct()
}

func (c *generatedTestTypes_codec) Decode(d *codecapi.Decoder) interface{} {
	var x generatedTestTypes
	c.decode(d, &x)
	return x
}

func (c *generatedTestTypes_codec) decode(d *codecapi.Decoder, x *generatedTestTypes) {
	d.StartStruct()
	for {
		n := d.NextStructField(c.fieldMap)
		if n == -1 {
			break
		}
		switch n {
		case 0:
			c.ptr_node_codec.decode(d, &x.Node)
		case 1:
			c.slice_int_codec.decode(d, &x.Slice)
		case 2:
			c.array_1_int_codec.decode(d, &x.Array)
		case 3:
			c.map_string_bool_codec.decode(d, &x.Map)
		case 4:
			c.structType_codec.decode(d, &x.Struct)
		case 5:
			c.time_Time_codec.decode(d, &x.Time)
		case 6:
			x.IP = net.IP(d.DecodeBytes())
		case 7:
			c.slice_structType_codec.decode(d, &x.StructSlice)
		case 8:
			c.array_1_structType_codec.decode(d, &x.StructArray)
		case 9:
			c.map__1_int_structType_codec.decode(d, &x.StructMap)
		case 10:
			c.definedSlice_codec.decode(d, &x.DefSlice)
		case 11:
			c.definedArray_codec.decode(d, &x.DefArray)
		case 12:
			c.definedMap_codec.decode(d, &x.DefMap)
		case 13:
			x.Pos = token.Pos(d.DecodeInt())
		case 14:
			c.foo_T_codec.decode(d, &x.T)
		default:
			d.UnknownField("generatedTestTypes", n)
		}
	}
}

func init() {
	codecapi.Register(generatedTestTypes{}, func() codecapi.TypeCodec { return &generatedTestTypes_codec{} })
	codecapi.Register(&generatedTestTypes{}, func() codecapi.TypeCodec { return &ptr_generatedTestTypes_codec{} })
}

// Fields of structType: N B unexported

var ptr_structType_type = reflect.TypeOf((*structType)(nil))

type ptr_structType_codec struct {
	structType_codec *structType_codec
}

func (c *ptr_structType_codec) Init(tcs map[reflect.Type]codecapi.TypeCodec, _ []int) {
	c.structType_codec = tcs[reflect.TypeOf((*structType)(nil)).Elem()].(*structType_codec)
}

func (c ptr_structType_codec) Fields() []string { return nil }

func (c ptr_structType_codec) TypesUsed() []reflect.Type { return []reflect.Type{structType_type} }

func (c ptr_structType_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*structType))
}

func (c ptr_structType_codec) encode(e *codecapi.Encoder, x *structType) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(&structType_codec{}).encode(e, x)
}

func (c ptr_structType_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *structType
	c.decode(d, &x)
	return x
}

func (c ptr_structType_codec) decode(d *codecapi.Decoder, p **structType) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*structType)
		return
	}
	var x structType
	d.StoreRef(&x)
	c.structType_codec.decode(d, &x)
	*p = &x
}

var structType_type = ptr_structType_type.Elem()

type structType_codec struct {
	node_codec *node_codec
	fieldMap   []int
}

func (c *structType_codec) Init(tcs map[reflect.Type]codecapi.TypeCodec, fieldMap []int) {
	c.node_codec = tcs[reflect.TypeOf((*node)(nil)).Elem()].(*node_codec)
	c.fieldMap = fieldMap
}

func (c *structType_codec) Fields() []string {
	return []string{"N", "B", "unexported"}
}

func (c *structType_codec) TypesUsed() []reflect.Type {
	return []reflect.Type{node_type}
}

func (c *structType_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(structType)
	c.encode(e, &s)
}

func (c *structType_codec) encode(e *codecapi.Encoder, x *structType) {
	e.StartStruct()

	e.EncodeUint(0)
	(&node_codec{}).encode(e, &x.N)
	if x.B != 0 {
		e.EncodeUint(1)
		e.EncodeByte(x.B)
	}
	if x.unexported != 0 {
		e.EncodeUint(2)
		e.EncodeInt(int64(x.unexported))
	}
	e.EndStruct()
}

func (c *structType_codec) Decode(d *codecapi.Decoder) interface{} {
	var x structType
	c.decode(d, &x)
	return x
}

func (c *structType_codec) decode(d *codecapi.Decoder, x *structType) {
	d.StartStruct()
	for {
		n := d.NextStructField(c.fieldMap)
		if n == -1 {
			break
		}
		switch n {
		case 0:
			c.node_codec.decode(d, &x.N)
		case 1:
			x.B = d.DecodeByte()
		case 2:
			x.unexported = int(d.DecodeInt())
		default:
			d.UnknownField("structType", n)
		}
	}
}

func init() {
	codecapi.Register(structType{}, func() codecapi.TypeCodec { return &structType_codec{} })
	codecapi.Register(&structType{}, func() codecapi.TypeCodec { return &ptr_structType_codec{} })
}

var foo_T_type = reflect.TypeOf((*foo.T)(nil)).Elem()

type foo_T_codec struct {
}

func (c *foo_T_codec) Init(tcs map[reflect.Type]codecapi.TypeCodec, _ []int) {

}

func (c *foo_T_codec) Fields() []string { return nil }

func (c *foo_T_codec) TypesUsed() []reflect.Type {
	return nil
}

func (c *foo_T_codec) Encode(e *codecapi.Encoder, x interface{}) { c.encode(e, x.(foo.T)) }

func (c *foo_T_codec) encode(e *codecapi.Encoder, s foo.T) {
	if s == nil {
		e.EncodeNil()
		return
	}
	e.StartList(len(s))
	for _, x := range s {
		e.EncodeInt(int64(x))
	}
}

func (c *foo_T_codec) Decode(d *codecapi.Decoder) interface{} {
	var x foo.T
	c.decode(d, &x)
	return x
}

func (c *foo_T_codec) decode(d *codecapi.Decoder, p *foo.T) {
	n := d.StartList()
	if n < 0 {
		return
	}
	s := make([]int, n)
	for i := 0; i < n; i++ {
		s[i] = int(d.DecodeInt())
	}
	*p = s
}

func init() {
	codecapi.Register(foo.T(nil), func() codecapi.TypeCodec { return &foo_T_codec{} })
}

var map__1_int_structType_type = reflect.TypeOf((*map[[1]int]structType)(nil)).Elem()

type map__1_int_structType_codec struct {
	array_1_int_codec *array_1_int_codec
	structType_codec  *structType_codec
}

func (c *map__1_int_structType_codec) Init(tcs map[reflect.Type]codecapi.TypeCodec, _ []int) {
	c.array_1_int_codec = tcs[reflect.TypeOf((*[1]int)(nil)).Elem()].(*array_1_int_codec)
	c.structType_codec = tcs[reflect.TypeOf((*structType)(nil)).Elem()].(*structType_codec)
}

func (c *map__1_int_structType_codec) Fields() []string { return nil }

func (c *map__1_int_structType_codec) TypesUsed() []reflect.Type {
	var types []reflect.Type
	types = append(types, array_1_int_type)

	types = append(types, structType_type)

	return types
}

func (c *map__1_int_structType_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(map[[1]int]structType))
}

func (c *map__1_int_structType_codec) encode(e *codecapi.Encoder, m map[[1]int]structType) {
	if m == nil {
		e.EncodeNil()
		return
	}
	e.StartList(2 * len(m))
	for k, v := range m {
		(&array_1_int_codec{}).encode(e, &k)
		(&structType_codec{}).encode(e, &v)
	}
}

func (c *map__1_int_structType_codec) Decode(d *codecapi.Decoder) interface{} {
	var x map[[1]int]structType
	c.decode(d, &x)
	return x
}

func (c *map__1_int_structType_codec) decode(d *codecapi.Decoder, p *map[[1]int]structType) {
	n2 := d.StartList()
	if n2 < 0 {
		return
	}
	n := n2 / 2
	m := make(map[[1]int]structType, n)
	var k [1]int
	var v structType
	for i := 0; i < n; i++ {
		c.array_1_int_codec.decode(d, &k)
		c.structType_codec.decode(d, &v)
		m[k] = v
	}
	*p = m
}

func init() {
	codecapi.Register(map[[1]int]structType(nil), func() codecapi.TypeCodec { return &map__1_int_structType_codec{} })
}

var map_string_bool_type = reflect.TypeOf((*map[string]bool)(nil)).Elem()

type map_string_bool_codec struct {
}

func (c *map_string_bool_codec) Init(tcs map[reflect.Type]codecapi.TypeCodec, _ []int) {
}

func (c *map_string_bool_codec) Fields() []string { return nil }

func (c *map_string_bool_codec) TypesUsed() []reflect.Type {
	var types []reflect.Type

	return types
}

func (c *map_string_bool_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(map[string]bool))
}

func (c *map_string_bool_codec) encode(e *codecapi.Encoder, m map[string]bool) {
	if m == nil {
		e.EncodeNil()
		return
	}
	e.StartList(2 * len(m))
	for k, v := range m {
		e.EncodeString(k)
		e.EncodeBool(v)
	}
}

func (c *map_string_bool_codec) Decode(d *codecapi.Decoder) interface{} {
	var x map[string]bool
	c.decode(d, &x)
	return x
}

func (c *map_string_bool_codec) decode(d *codecapi.Decoder, p *map[string]bool) {
	n2 := d.StartList()
	if n2 < 0 {
		return
	}
	n := n2 / 2
	m := make(map[string]bool, n)
	var k string
	var v bool
	for i := 0; i < n; i++ {
		k = d.DecodeString()
		v = d.DecodeBool()
		m[k] = v
	}
	*p = m
}

func init() {
	codecapi.Register(map[string]bool(nil), func() codecapi.TypeCodec { return &map_string_bool_codec{} })
}

var net_IP_type = reflect.TypeOf((*net.IP)(nil)).Elem()

type net_IP_codec struct{}

func (c *net_IP_codec) Fields() []string { return nil }

func (c *net_IP_codec) Init(map[reflect.Type]codecapi.TypeCodec, []int) {}

func (c *net_IP_codec) TypesUsed() []reflect.Type { return nil }

func (c *net_IP_codec) Encode(e *codecapi.Encoder, x interface{}) { c.encode(e, x.(net.IP)) }

func (c *net_IP_codec) encode(e *codecapi.Encoder, m net.IP) {
	data, err := m.MarshalText()
	if err != nil {
		codecapi.Fail(err)
	}
	e.EncodeBytes(data)
}

func (c *net_IP_codec) Decode(d *codecapi.Decoder) interface{} {
	var x net.IP
	c.decode(d, &x)
	return x
}

func (c *net_IP_codec) decode(d *codecapi.Decoder, p *net.IP) {
	data := d.DecodeBytes()
	if err := p.UnmarshalText(data); err != nil {
		codecapi.Fail(err)
	}
}

func init() { codecapi.Register(*new(net.IP), func() codecapi.TypeCodec { return &net_IP_codec{} }) }

var time_Time_type = reflect.TypeOf((*time.Time)(nil)).Elem()

type time_Time_codec struct{}

func (c *time_Time_codec) Fields() []string { return nil }

func (c *time_Time_codec) Init(map[reflect.Type]codecapi.TypeCodec, []int) {}

func (c *time_Time_codec) TypesUsed() []reflect.Type { return nil }

func (c *time_Time_codec) Encode(e *codecapi.Encoder, x interface{}) { c.encode(e, x.(time.Time)) }

func (c *time_Time_codec) encode(e *codecapi.Encoder, m time.Time) {
	data, err := m.MarshalBinary()
	if err != nil {
		codecapi.Fail(err)
	}
	e.EncodeBytes(data)
}

func (c *time_Time_codec) Decode(d *codecapi.Decoder) interface{} {
	var x time.Time
	c.decode(d, &x)
	return x
}

func (c *time_Time_codec) decode(d *codecapi.Decoder, p *time.Time) {
	data := d.DecodeBytes()
	if err := p.UnmarshalBinary(data); err != nil {
		codecapi.Fail(err)
	}
}

func init() {
	codecapi.Register(*new(time.Time), func() codecapi.TypeCodec { return &time_Time_codec{} })
}
