// Code generated by the codec package. DO NOT EDIT.

package main

import (
	"github.com/google/licensecheck"
	"github.com/jba/codec"
	"time"
)

// Fields of LicenseData: Files Contents

type ptr_LicenseData_codec struct{}

func (ptr_LicenseData_codec) Init() {}

func (c ptr_LicenseData_codec) Encode(e *codec.Encoder, x interface{}) { c.encode(e, x.(*LicenseData)) }

func (c ptr_LicenseData_codec) encode(e *codec.Encoder, x *LicenseData) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(LicenseData_codec{}).encode(e, x)
}

func (c ptr_LicenseData_codec) Decode(d *codec.Decoder) interface{} {
	var x *LicenseData
	c.decode(d, &x)
	return x
}

func (c ptr_LicenseData_codec) decode(d *codec.Decoder, p **LicenseData) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*LicenseData)
		return
	}
	var x LicenseData
	d.StoreRef(&x)
	(LicenseData_codec{}).decode(d, &x)
	*p = &x
}

type LicenseData_codec struct{}

func (LicenseData_codec) Init() {}

func (c LicenseData_codec) Encode(e *codec.Encoder, x interface{}) {
	s := x.(LicenseData)
	c.encode(e, &s)
}

func (c LicenseData_codec) encode(e *codec.Encoder, x *LicenseData) {
	e.StartStruct()
	if x.Files != nil {
		e.EncodeUint(0)
		(slice_ptr_LicenseFile_codec{}).encode(e, x.Files)
	}
	if x.Contents != nil {
		e.EncodeUint(1)
		(slice_ptr_LicenseContents_codec{}).encode(e, x.Contents)
	}
	e.EndStruct()
}

func (c LicenseData_codec) Decode(d *codec.Decoder) interface{} {
	var x LicenseData
	c.decode(d, &x)
	return x
}

func (c LicenseData_codec) decode(d *codec.Decoder, x *LicenseData) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			(slice_ptr_LicenseFile_codec{}).decode(d, &x.Files)
		case 1:
			(slice_ptr_LicenseContents_codec{}).decode(d, &x.Contents)
		default:
			d.UnknownField("LicenseData", n)
		}
	}
}

func init() {
	codec.Register(LicenseData{}, LicenseData_codec{})
	codec.Register(&LicenseData{}, ptr_LicenseData_codec{})
}

type submittedData_codec struct{}

func (c submittedData_codec) Init() {}

func (c submittedData_codec) Encode(e *codec.Encoder, x interface{}) { c.encode(e, x.(submittedData)) }

func (c submittedData_codec) encode(e *codec.Encoder, m submittedData) {
	if m == nil {
		e.EncodeNil()
		return
	}
	e.StartList(2 * len(m))
	for k, v := range m {
		e.EncodeString(k)
		(ptr_submittedLedgerData_codec{}).encode(e, v)
	}
}

func (c submittedData_codec) Decode(d *codec.Decoder) interface{} {
	var x submittedData
	c.decode(d, &x)
	return x
}

func (c submittedData_codec) decode(d *codec.Decoder, p *submittedData) {
	n2 := d.StartList()
	if n2 < 0 {
		return
	}
	n := n2 / 2
	m := make(submittedData, n)
	var k string
	var v *submittedLedgerData
	for i := 0; i < n; i++ {
		k = d.DecodeString()
		(ptr_submittedLedgerData_codec{}).decode(d, &v)
		m[k] = v
	}
	*p = m
}

func init() { codec.Register(submittedData(nil), submittedData_codec{}) }

type slice_ptr_StockData_codec struct{}

func (slice_ptr_StockData_codec) Init() {}

func (c slice_ptr_StockData_codec) Encode(e *codec.Encoder, x interface{}) {
	c.encode(e, x.([]*StockData))
}

func (c slice_ptr_StockData_codec) encode(e *codec.Encoder, s []*StockData) {
	if s == nil {
		e.EncodeNil()
		return
	}
	e.StartList(len(s))
	for _, x := range s {
		(ptr_StockData_codec{}).encode(e, x)
	}
}

func (c slice_ptr_StockData_codec) Decode(d *codec.Decoder) interface{} {
	var x []*StockData
	c.decode(d, &x)
	return x
}

func (c slice_ptr_StockData_codec) decode(d *codec.Decoder, p *[]*StockData) {
	n := d.StartList()
	if n < 0 {
		return
	}
	s := make([]*StockData, n)
	for i := 0; i < n; i++ {
		(ptr_StockData_codec{}).decode(d, &s[i])
	}
	*p = s
}

func init() {
	codec.Register([]*StockData(nil), slice_ptr_StockData_codec{})
}

type slice_ptr_LicenseFile_codec struct{}

func (slice_ptr_LicenseFile_codec) Init() {}

func (c slice_ptr_LicenseFile_codec) Encode(e *codec.Encoder, x interface{}) {
	c.encode(e, x.([]*LicenseFile))
}

func (c slice_ptr_LicenseFile_codec) encode(e *codec.Encoder, s []*LicenseFile) {
	if s == nil {
		e.EncodeNil()
		return
	}
	e.StartList(len(s))
	for _, x := range s {
		(ptr_LicenseFile_codec{}).encode(e, x)
	}
}

func (c slice_ptr_LicenseFile_codec) Decode(d *codec.Decoder) interface{} {
	var x []*LicenseFile
	c.decode(d, &x)
	return x
}

func (c slice_ptr_LicenseFile_codec) decode(d *codec.Decoder, p *[]*LicenseFile) {
	n := d.StartList()
	if n < 0 {
		return
	}
	s := make([]*LicenseFile, n)
	for i := 0; i < n; i++ {
		(ptr_LicenseFile_codec{}).decode(d, &s[i])
	}
	*p = s
}

func init() {
	codec.Register([]*LicenseFile(nil), slice_ptr_LicenseFile_codec{})
}

type slice_ptr_LicenseContents_codec struct{}

func (slice_ptr_LicenseContents_codec) Init() {}

func (c slice_ptr_LicenseContents_codec) Encode(e *codec.Encoder, x interface{}) {
	c.encode(e, x.([]*LicenseContents))
}

func (c slice_ptr_LicenseContents_codec) encode(e *codec.Encoder, s []*LicenseContents) {
	if s == nil {
		e.EncodeNil()
		return
	}
	e.StartList(len(s))
	for _, x := range s {
		(ptr_LicenseContents_codec{}).encode(e, x)
	}
}

func (c slice_ptr_LicenseContents_codec) Decode(d *codec.Decoder) interface{} {
	var x []*LicenseContents
	c.decode(d, &x)
	return x
}

func (c slice_ptr_LicenseContents_codec) decode(d *codec.Decoder, p *[]*LicenseContents) {
	n := d.StartList()
	if n < 0 {
		return
	}
	s := make([]*LicenseContents, n)
	for i := 0; i < n; i++ {
		(ptr_LicenseContents_codec{}).decode(d, &s[i])
	}
	*p = s
}

func init() {
	codec.Register([]*LicenseContents(nil), slice_ptr_LicenseContents_codec{})
}

// Fields of submittedLedgerData: Blocks Txs

type ptr_submittedLedgerData_codec struct{}

func (ptr_submittedLedgerData_codec) Init() {}

func (c ptr_submittedLedgerData_codec) Encode(e *codec.Encoder, x interface{}) {
	c.encode(e, x.(*submittedLedgerData))
}

func (c ptr_submittedLedgerData_codec) encode(e *codec.Encoder, x *submittedLedgerData) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(submittedLedgerData_codec{}).encode(e, x)
}

func (c ptr_submittedLedgerData_codec) Decode(d *codec.Decoder) interface{} {
	var x *submittedLedgerData
	c.decode(d, &x)
	return x
}

func (c ptr_submittedLedgerData_codec) decode(d *codec.Decoder, p **submittedLedgerData) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*submittedLedgerData)
		return
	}
	var x submittedLedgerData
	d.StoreRef(&x)
	(submittedLedgerData_codec{}).decode(d, &x)
	*p = &x
}

type submittedLedgerData_codec struct{}

func (submittedLedgerData_codec) Init() {}

func (c submittedLedgerData_codec) Encode(e *codec.Encoder, x interface{}) {
	s := x.(submittedLedgerData)
	c.encode(e, &s)
}

func (c submittedLedgerData_codec) encode(e *codec.Encoder, x *submittedLedgerData) {
	e.StartStruct()
	if x.Blocks != nil {
		e.EncodeUint(0)
		(slice_ptr_BlockAndPvtData_codec{}).encode(e, x.Blocks)
	}
	if x.Txs != nil {
		e.EncodeUint(1)
		(slice_ptr_txAndPvtdata_codec{}).encode(e, x.Txs)
	}
	e.EndStruct()
}

func (c submittedLedgerData_codec) Decode(d *codec.Decoder) interface{} {
	var x submittedLedgerData
	c.decode(d, &x)
	return x
}

func (c submittedLedgerData_codec) decode(d *codec.Decoder, x *submittedLedgerData) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			(slice_ptr_BlockAndPvtData_codec{}).decode(d, &x.Blocks)
		case 1:
			(slice_ptr_txAndPvtdata_codec{}).decode(d, &x.Txs)
		default:
			d.UnknownField("submittedLedgerData", n)
		}
	}
}

func init() {
	codec.Register(submittedLedgerData{}, submittedLedgerData_codec{})
	codec.Register(&submittedLedgerData{}, ptr_submittedLedgerData_codec{})
}

// Fields of StockData: Symbol Intervals

type ptr_StockData_codec struct{}

func (ptr_StockData_codec) Init() {}

func (c ptr_StockData_codec) Encode(e *codec.Encoder, x interface{}) { c.encode(e, x.(*StockData)) }

func (c ptr_StockData_codec) encode(e *codec.Encoder, x *StockData) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(StockData_codec{}).encode(e, x)
}

func (c ptr_StockData_codec) Decode(d *codec.Decoder) interface{} {
	var x *StockData
	c.decode(d, &x)
	return x
}

func (c ptr_StockData_codec) decode(d *codec.Decoder, p **StockData) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*StockData)
		return
	}
	var x StockData
	d.StoreRef(&x)
	(StockData_codec{}).decode(d, &x)
	*p = &x
}

type StockData_codec struct{}

func (StockData_codec) Init() {}

func (c StockData_codec) Encode(e *codec.Encoder, x interface{}) {
	s := x.(StockData)
	c.encode(e, &s)
}

func (c StockData_codec) encode(e *codec.Encoder, x *StockData) {
	e.StartStruct()
	if x.Symbol != "" {
		e.EncodeUint(0)
		e.EncodeString(x.Symbol)
	}
	if x.Intervals != nil {
		e.EncodeUint(1)
		(slice_Interval_codec{}).encode(e, x.Intervals)
	}
	e.EndStruct()
}

func (c StockData_codec) Decode(d *codec.Decoder) interface{} {
	var x StockData
	c.decode(d, &x)
	return x
}

func (c StockData_codec) decode(d *codec.Decoder, x *StockData) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Symbol = d.DecodeString()
		case 1:
			(slice_Interval_codec{}).decode(d, &x.Intervals)
		default:
			d.UnknownField("StockData", n)
		}
	}
}

func init() {
	codec.Register(StockData{}, StockData_codec{})
	codec.Register(&StockData{}, ptr_StockData_codec{})
}

// Fields of LicenseFile: Module Version FilePath Contents

type ptr_LicenseFile_codec struct{}

func (ptr_LicenseFile_codec) Init() {}

func (c ptr_LicenseFile_codec) Encode(e *codec.Encoder, x interface{}) { c.encode(e, x.(*LicenseFile)) }

func (c ptr_LicenseFile_codec) encode(e *codec.Encoder, x *LicenseFile) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(LicenseFile_codec{}).encode(e, x)
}

func (c ptr_LicenseFile_codec) Decode(d *codec.Decoder) interface{} {
	var x *LicenseFile
	c.decode(d, &x)
	return x
}

func (c ptr_LicenseFile_codec) decode(d *codec.Decoder, p **LicenseFile) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*LicenseFile)
		return
	}
	var x LicenseFile
	d.StoreRef(&x)
	(LicenseFile_codec{}).decode(d, &x)
	*p = &x
}

type LicenseFile_codec struct{}

func (LicenseFile_codec) Init() {}

func (c LicenseFile_codec) Encode(e *codec.Encoder, x interface{}) {
	s := x.(LicenseFile)
	c.encode(e, &s)
}

func (c LicenseFile_codec) encode(e *codec.Encoder, x *LicenseFile) {
	e.StartStruct()
	if x.Module != "" {
		e.EncodeUint(0)
		e.EncodeString(x.Module)
	}
	if x.Version != "" {
		e.EncodeUint(1)
		e.EncodeString(x.Version)
	}
	if x.FilePath != "" {
		e.EncodeUint(2)
		e.EncodeString(x.FilePath)
	}
	if x.Contents != 0 {
		e.EncodeUint(3)
		e.EncodeInt(int64(x.Contents))
	}
	e.EndStruct()
}

func (c LicenseFile_codec) Decode(d *codec.Decoder) interface{} {
	var x LicenseFile
	c.decode(d, &x)
	return x
}

func (c LicenseFile_codec) decode(d *codec.Decoder, x *LicenseFile) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Module = d.DecodeString()
		case 1:
			x.Version = d.DecodeString()
		case 2:
			x.FilePath = d.DecodeString()
		case 3:
			x.Contents = int(d.DecodeInt())
		default:
			d.UnknownField("LicenseFile", n)
		}
	}
}

func init() {
	codec.Register(LicenseFile{}, LicenseFile_codec{})
	codec.Register(&LicenseFile{}, ptr_LicenseFile_codec{})
}

// Fields of LicenseContents: Contents ContentsHash OldTypes OldCoverage NewTypes NewCoverage

type ptr_LicenseContents_codec struct{}

func (ptr_LicenseContents_codec) Init() {}

func (c ptr_LicenseContents_codec) Encode(e *codec.Encoder, x interface{}) {
	c.encode(e, x.(*LicenseContents))
}

func (c ptr_LicenseContents_codec) encode(e *codec.Encoder, x *LicenseContents) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(LicenseContents_codec{}).encode(e, x)
}

func (c ptr_LicenseContents_codec) Decode(d *codec.Decoder) interface{} {
	var x *LicenseContents
	c.decode(d, &x)
	return x
}

func (c ptr_LicenseContents_codec) decode(d *codec.Decoder, p **LicenseContents) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*LicenseContents)
		return
	}
	var x LicenseContents
	d.StoreRef(&x)
	(LicenseContents_codec{}).decode(d, &x)
	*p = &x
}

type LicenseContents_codec struct{}

func (LicenseContents_codec) Init() {}

func (c LicenseContents_codec) Encode(e *codec.Encoder, x interface{}) {
	s := x.(LicenseContents)
	c.encode(e, &s)
}

func (c LicenseContents_codec) encode(e *codec.Encoder, x *LicenseContents) {
	e.StartStruct()
	if x.Contents != nil {
		e.EncodeUint(0)
		e.EncodeBytes(x.Contents)
	}

	e.EncodeUint(1)
	(array_32_uint8_codec{}).encode(e, &x.ContentsHash)
	if x.OldTypes != nil {
		e.EncodeUint(2)
		(slice_string_codec{}).encode(e, x.OldTypes)
	}

	e.EncodeUint(3)
	(licensecheck_Coverage_codec{}).encode(e, &x.OldCoverage)
	if x.NewTypes != nil {
		e.EncodeUint(4)
		(slice_string_codec{}).encode(e, x.NewTypes)
	}

	e.EncodeUint(5)
	(licensecheck_Coverage_codec{}).encode(e, &x.NewCoverage)
	e.EndStruct()
}

func (c LicenseContents_codec) Decode(d *codec.Decoder) interface{} {
	var x LicenseContents
	c.decode(d, &x)
	return x
}

func (c LicenseContents_codec) decode(d *codec.Decoder, x *LicenseContents) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Contents = d.DecodeBytes()
		case 1:
			(array_32_uint8_codec{}).decode(d, &x.ContentsHash)
		case 2:
			(slice_string_codec{}).decode(d, &x.OldTypes)
		case 3:
			(licensecheck_Coverage_codec{}).decode(d, &x.OldCoverage)
		case 4:
			(slice_string_codec{}).decode(d, &x.NewTypes)
		case 5:
			(licensecheck_Coverage_codec{}).decode(d, &x.NewCoverage)
		default:
			d.UnknownField("LicenseContents", n)
		}
	}
}

func init() {
	codec.Register(LicenseContents{}, LicenseContents_codec{})
	codec.Register(&LicenseContents{}, ptr_LicenseContents_codec{})
}

type slice_ptr_BlockAndPvtData_codec struct{}

func (slice_ptr_BlockAndPvtData_codec) Init() {}

func (c slice_ptr_BlockAndPvtData_codec) Encode(e *codec.Encoder, x interface{}) {
	c.encode(e, x.([]*BlockAndPvtData))
}

func (c slice_ptr_BlockAndPvtData_codec) encode(e *codec.Encoder, s []*BlockAndPvtData) {
	if s == nil {
		e.EncodeNil()
		return
	}
	e.StartList(len(s))
	for _, x := range s {
		(ptr_BlockAndPvtData_codec{}).encode(e, x)
	}
}

func (c slice_ptr_BlockAndPvtData_codec) Decode(d *codec.Decoder) interface{} {
	var x []*BlockAndPvtData
	c.decode(d, &x)
	return x
}

func (c slice_ptr_BlockAndPvtData_codec) decode(d *codec.Decoder, p *[]*BlockAndPvtData) {
	n := d.StartList()
	if n < 0 {
		return
	}
	s := make([]*BlockAndPvtData, n)
	for i := 0; i < n; i++ {
		(ptr_BlockAndPvtData_codec{}).decode(d, &s[i])
	}
	*p = s
}

func init() {
	codec.Register([]*BlockAndPvtData(nil), slice_ptr_BlockAndPvtData_codec{})
}

type slice_ptr_txAndPvtdata_codec struct{}

func (slice_ptr_txAndPvtdata_codec) Init() {}

func (c slice_ptr_txAndPvtdata_codec) Encode(e *codec.Encoder, x interface{}) {
	c.encode(e, x.([]*txAndPvtdata))
}

func (c slice_ptr_txAndPvtdata_codec) encode(e *codec.Encoder, s []*txAndPvtdata) {
	if s == nil {
		e.EncodeNil()
		return
	}
	e.StartList(len(s))
	for _, x := range s {
		(ptr_txAndPvtdata_codec{}).encode(e, x)
	}
}

func (c slice_ptr_txAndPvtdata_codec) Decode(d *codec.Decoder) interface{} {
	var x []*txAndPvtdata
	c.decode(d, &x)
	return x
}

func (c slice_ptr_txAndPvtdata_codec) decode(d *codec.Decoder, p *[]*txAndPvtdata) {
	n := d.StartList()
	if n < 0 {
		return
	}
	s := make([]*txAndPvtdata, n)
	for i := 0; i < n; i++ {
		(ptr_txAndPvtdata_codec{}).decode(d, &s[i])
	}
	*p = s
}

func init() {
	codec.Register([]*txAndPvtdata(nil), slice_ptr_txAndPvtdata_codec{})
}

type slice_Interval_codec struct{}

func (slice_Interval_codec) Init() {}

func (c slice_Interval_codec) Encode(e *codec.Encoder, x interface{}) { c.encode(e, x.([]Interval)) }

func (c slice_Interval_codec) encode(e *codec.Encoder, s []Interval) {
	if s == nil {
		e.EncodeNil()
		return
	}
	e.StartList(len(s))
	for _, x := range s {
		(Interval_codec{}).encode(e, &x)
	}
}

func (c slice_Interval_codec) Decode(d *codec.Decoder) interface{} {
	var x []Interval
	c.decode(d, &x)
	return x
}

func (c slice_Interval_codec) decode(d *codec.Decoder, p *[]Interval) {
	n := d.StartList()
	if n < 0 {
		return
	}
	s := make([]Interval, n)
	for i := 0; i < n; i++ {
		(Interval_codec{}).decode(d, &s[i])
	}
	*p = s
}

func init() {
	codec.Register([]Interval(nil), slice_Interval_codec{})
}

type array_32_uint8_codec struct{}

func (array_32_uint8_codec) Init() {}

func (c array_32_uint8_codec) Encode(e *codec.Encoder, x interface{}) {
	a := x.([32]uint8)
	c.encode(e, &a)
}

func (c array_32_uint8_codec) encode(e *codec.Encoder, s *[32]uint8) {
	e.EncodeBytes((*s)[:])
}

func (c array_32_uint8_codec) Decode(d *codec.Decoder) interface{} {
	var x [32]uint8
	c.decode(d, &x)
	return x
}

func (c array_32_uint8_codec) decode(d *codec.Decoder, p *[32]uint8) {
	b := d.DecodeBytes()
	copy((*p)[:], b)
}

func init() {
	codec.Register([32]uint8{}, array_32_uint8_codec{})
}

type slice_string_codec struct{}

func (slice_string_codec) Init() {}

func (c slice_string_codec) Encode(e *codec.Encoder, x interface{}) { c.encode(e, x.([]string)) }

func (c slice_string_codec) encode(e *codec.Encoder, s []string) {
	if s == nil {
		e.EncodeNil()
		return
	}
	e.StartList(len(s))
	for _, x := range s {
		e.EncodeString(x)
	}
}

func (c slice_string_codec) Decode(d *codec.Decoder) interface{} {
	var x []string
	c.decode(d, &x)
	return x
}

func (c slice_string_codec) decode(d *codec.Decoder, p *[]string) {
	n := d.StartList()
	if n < 0 {
		return
	}
	s := make([]string, n)
	for i := 0; i < n; i++ {
		s[i] = d.DecodeString()
	}
	*p = s
}

func init() {
	codec.Register([]string(nil), slice_string_codec{})
}

// Fields of licensecheck_Coverage: Percent Match

type ptr_licensecheck_Coverage_codec struct{}

func (ptr_licensecheck_Coverage_codec) Init() {}

func (c ptr_licensecheck_Coverage_codec) Encode(e *codec.Encoder, x interface{}) {
	c.encode(e, x.(*licensecheck.Coverage))
}

func (c ptr_licensecheck_Coverage_codec) encode(e *codec.Encoder, x *licensecheck.Coverage) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(licensecheck_Coverage_codec{}).encode(e, x)
}

func (c ptr_licensecheck_Coverage_codec) Decode(d *codec.Decoder) interface{} {
	var x *licensecheck.Coverage
	c.decode(d, &x)
	return x
}

func (c ptr_licensecheck_Coverage_codec) decode(d *codec.Decoder, p **licensecheck.Coverage) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*licensecheck.Coverage)
		return
	}
	var x licensecheck.Coverage
	d.StoreRef(&x)
	(licensecheck_Coverage_codec{}).decode(d, &x)
	*p = &x
}

type licensecheck_Coverage_codec struct{}

func (licensecheck_Coverage_codec) Init() {}

func (c licensecheck_Coverage_codec) Encode(e *codec.Encoder, x interface{}) {
	s := x.(licensecheck.Coverage)
	c.encode(e, &s)
}

func (c licensecheck_Coverage_codec) encode(e *codec.Encoder, x *licensecheck.Coverage) {
	e.StartStruct()
	if x.Percent != 0 {
		e.EncodeUint(0)
		e.EncodeFloat(x.Percent)
	}
	if x.Match != nil {
		e.EncodeUint(1)
		(slice_licensecheck_Match_codec{}).encode(e, x.Match)
	}
	e.EndStruct()
}

func (c licensecheck_Coverage_codec) Decode(d *codec.Decoder) interface{} {
	var x licensecheck.Coverage
	c.decode(d, &x)
	return x
}

func (c licensecheck_Coverage_codec) decode(d *codec.Decoder, x *licensecheck.Coverage) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Percent = d.DecodeFloat()
		case 1:
			(slice_licensecheck_Match_codec{}).decode(d, &x.Match)
		default:
			d.UnknownField("licensecheck.Coverage", n)
		}
	}
}

func init() {
	codec.Register(licensecheck.Coverage{}, licensecheck_Coverage_codec{})
	codec.Register(&licensecheck.Coverage{}, ptr_licensecheck_Coverage_codec{})
}

// Fields of BlockAndPvtData: Block PvtData MissingPvtData

type ptr_BlockAndPvtData_codec struct{}

func (ptr_BlockAndPvtData_codec) Init() {}

func (c ptr_BlockAndPvtData_codec) Encode(e *codec.Encoder, x interface{}) {
	c.encode(e, x.(*BlockAndPvtData))
}

func (c ptr_BlockAndPvtData_codec) encode(e *codec.Encoder, x *BlockAndPvtData) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(BlockAndPvtData_codec{}).encode(e, x)
}

func (c ptr_BlockAndPvtData_codec) Decode(d *codec.Decoder) interface{} {
	var x *BlockAndPvtData
	c.decode(d, &x)
	return x
}

func (c ptr_BlockAndPvtData_codec) decode(d *codec.Decoder, p **BlockAndPvtData) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*BlockAndPvtData)
		return
	}
	var x BlockAndPvtData
	d.StoreRef(&x)
	(BlockAndPvtData_codec{}).decode(d, &x)
	*p = &x
}

type BlockAndPvtData_codec struct{}

func (BlockAndPvtData_codec) Init() {}

func (c BlockAndPvtData_codec) Encode(e *codec.Encoder, x interface{}) {
	s := x.(BlockAndPvtData)
	c.encode(e, &s)
}

func (c BlockAndPvtData_codec) encode(e *codec.Encoder, x *BlockAndPvtData) {
	e.StartStruct()
	if x.Block != nil {
		e.EncodeUint(0)
		(ptr_Block_codec{}).encode(e, x.Block)
	}
	if x.PvtData != nil {
		e.EncodeUint(1)
		(TxPvtDataMap_codec{}).encode(e, TxPvtDataMap(x.PvtData))
	}
	if x.MissingPvtData != nil {
		e.EncodeUint(2)
		(TxMissingPvtData_codec{}).encode(e, TxMissingPvtData(x.MissingPvtData))
	}
	e.EndStruct()
}

func (c BlockAndPvtData_codec) Decode(d *codec.Decoder) interface{} {
	var x BlockAndPvtData
	c.decode(d, &x)
	return x
}

func (c BlockAndPvtData_codec) decode(d *codec.Decoder, x *BlockAndPvtData) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			(ptr_Block_codec{}).decode(d, &x.Block)
		case 1:
			(TxPvtDataMap_codec{}).decode(d, &x.PvtData)
		case 2:
			(TxMissingPvtData_codec{}).decode(d, &x.MissingPvtData)
		default:
			d.UnknownField("BlockAndPvtData", n)
		}
	}
}

func init() {
	codec.Register(BlockAndPvtData{}, BlockAndPvtData_codec{})
	codec.Register(&BlockAndPvtData{}, ptr_BlockAndPvtData_codec{})
}

// Fields of txAndPvtdata: Txid Envelope Pvtws

type ptr_txAndPvtdata_codec struct{}

func (ptr_txAndPvtdata_codec) Init() {}

func (c ptr_txAndPvtdata_codec) Encode(e *codec.Encoder, x interface{}) {
	c.encode(e, x.(*txAndPvtdata))
}

func (c ptr_txAndPvtdata_codec) encode(e *codec.Encoder, x *txAndPvtdata) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(txAndPvtdata_codec{}).encode(e, x)
}

func (c ptr_txAndPvtdata_codec) Decode(d *codec.Decoder) interface{} {
	var x *txAndPvtdata
	c.decode(d, &x)
	return x
}

func (c ptr_txAndPvtdata_codec) decode(d *codec.Decoder, p **txAndPvtdata) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*txAndPvtdata)
		return
	}
	var x txAndPvtdata
	d.StoreRef(&x)
	(txAndPvtdata_codec{}).decode(d, &x)
	*p = &x
}

type txAndPvtdata_codec struct{}

func (txAndPvtdata_codec) Init() {}

func (c txAndPvtdata_codec) Encode(e *codec.Encoder, x interface{}) {
	s := x.(txAndPvtdata)
	c.encode(e, &s)
}

func (c txAndPvtdata_codec) encode(e *codec.Encoder, x *txAndPvtdata) {
	e.StartStruct()
	if x.Txid != "" {
		e.EncodeUint(0)
		e.EncodeString(x.Txid)
	}
	if x.Envelope != nil {
		e.EncodeUint(1)
		(ptr_Envelope_codec{}).encode(e, x.Envelope)
	}
	if x.Pvtws != nil {
		e.EncodeUint(2)
		(ptr_TxPvtReadWriteSet_codec{}).encode(e, x.Pvtws)
	}
	e.EndStruct()
}

func (c txAndPvtdata_codec) Decode(d *codec.Decoder) interface{} {
	var x txAndPvtdata
	c.decode(d, &x)
	return x
}

func (c txAndPvtdata_codec) decode(d *codec.Decoder, x *txAndPvtdata) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Txid = d.DecodeString()
		case 1:
			(ptr_Envelope_codec{}).decode(d, &x.Envelope)
		case 2:
			(ptr_TxPvtReadWriteSet_codec{}).decode(d, &x.Pvtws)
		default:
			d.UnknownField("txAndPvtdata", n)
		}
	}
}

func init() {
	codec.Register(txAndPvtdata{}, txAndPvtdata_codec{})
	codec.Register(&txAndPvtdata{}, ptr_txAndPvtdata_codec{})
}

// Fields of Interval: Start End Open Close Low High Volume

type ptr_Interval_codec struct{}

func (ptr_Interval_codec) Init() {}

func (c ptr_Interval_codec) Encode(e *codec.Encoder, x interface{}) { c.encode(e, x.(*Interval)) }

func (c ptr_Interval_codec) encode(e *codec.Encoder, x *Interval) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(Interval_codec{}).encode(e, x)
}

func (c ptr_Interval_codec) Decode(d *codec.Decoder) interface{} {
	var x *Interval
	c.decode(d, &x)
	return x
}

func (c ptr_Interval_codec) decode(d *codec.Decoder, p **Interval) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*Interval)
		return
	}
	var x Interval
	d.StoreRef(&x)
	(Interval_codec{}).decode(d, &x)
	*p = &x
}

type Interval_codec struct{}

func (Interval_codec) Init() {}

func (c Interval_codec) Encode(e *codec.Encoder, x interface{}) {
	s := x.(Interval)
	c.encode(e, &s)
}

func (c Interval_codec) encode(e *codec.Encoder, x *Interval) {
	e.StartStruct()

	e.EncodeUint(0)
	(time_Time_codec{}).encode(e, x.Start)

	e.EncodeUint(1)
	(time_Time_codec{}).encode(e, x.End)
	if x.Open != 0 {
		e.EncodeUint(2)
		e.EncodeFloat(x.Open)
	}
	if x.Close != 0 {
		e.EncodeUint(3)
		e.EncodeFloat(x.Close)
	}
	if x.Low != 0 {
		e.EncodeUint(4)
		e.EncodeFloat(x.Low)
	}
	if x.High != 0 {
		e.EncodeUint(5)
		e.EncodeFloat(x.High)
	}
	if x.Volume != 0 {
		e.EncodeUint(6)
		e.EncodeFloat(x.Volume)
	}
	e.EndStruct()
}

func (c Interval_codec) Decode(d *codec.Decoder) interface{} {
	var x Interval
	c.decode(d, &x)
	return x
}

func (c Interval_codec) decode(d *codec.Decoder, x *Interval) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			(time_Time_codec{}).decode(d, &x.Start)
		case 1:
			(time_Time_codec{}).decode(d, &x.End)
		case 2:
			x.Open = d.DecodeFloat()
		case 3:
			x.Close = d.DecodeFloat()
		case 4:
			x.Low = d.DecodeFloat()
		case 5:
			x.High = d.DecodeFloat()
		case 6:
			x.Volume = d.DecodeFloat()
		default:
			d.UnknownField("Interval", n)
		}
	}
}

func init() {
	codec.Register(Interval{}, Interval_codec{})
	codec.Register(&Interval{}, ptr_Interval_codec{})
}

type slice_licensecheck_Match_codec struct{}

func (slice_licensecheck_Match_codec) Init() {}

func (c slice_licensecheck_Match_codec) Encode(e *codec.Encoder, x interface{}) {
	c.encode(e, x.([]licensecheck.Match))
}

func (c slice_licensecheck_Match_codec) encode(e *codec.Encoder, s []licensecheck.Match) {
	if s == nil {
		e.EncodeNil()
		return
	}
	e.StartList(len(s))
	for _, x := range s {
		(licensecheck_Match_codec{}).encode(e, &x)
	}
}

func (c slice_licensecheck_Match_codec) Decode(d *codec.Decoder) interface{} {
	var x []licensecheck.Match
	c.decode(d, &x)
	return x
}

func (c slice_licensecheck_Match_codec) decode(d *codec.Decoder, p *[]licensecheck.Match) {
	n := d.StartList()
	if n < 0 {
		return
	}
	s := make([]licensecheck.Match, n)
	for i := 0; i < n; i++ {
		(licensecheck_Match_codec{}).decode(d, &s[i])
	}
	*p = s
}

func init() {
	codec.Register([]licensecheck.Match(nil), slice_licensecheck_Match_codec{})
}

// Fields of Block: Header Data Metadata

type ptr_Block_codec struct{}

func (ptr_Block_codec) Init() {}

func (c ptr_Block_codec) Encode(e *codec.Encoder, x interface{}) { c.encode(e, x.(*Block)) }

func (c ptr_Block_codec) encode(e *codec.Encoder, x *Block) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(Block_codec{}).encode(e, x)
}

func (c ptr_Block_codec) Decode(d *codec.Decoder) interface{} {
	var x *Block
	c.decode(d, &x)
	return x
}

func (c ptr_Block_codec) decode(d *codec.Decoder, p **Block) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*Block)
		return
	}
	var x Block
	d.StoreRef(&x)
	(Block_codec{}).decode(d, &x)
	*p = &x
}

type Block_codec struct{}

func (Block_codec) Init() {}

func (c Block_codec) Encode(e *codec.Encoder, x interface{}) {
	s := x.(Block)
	c.encode(e, &s)
}

func (c Block_codec) encode(e *codec.Encoder, x *Block) {
	e.StartStruct()
	if x.Header != nil {
		e.EncodeUint(0)
		(ptr_BlockHeader_codec{}).encode(e, x.Header)
	}
	if x.Data != nil {
		e.EncodeUint(1)
		(ptr_BlockData_codec{}).encode(e, x.Data)
	}
	if x.Metadata != nil {
		e.EncodeUint(2)
		(ptr_BlockMetadata_codec{}).encode(e, x.Metadata)
	}
	e.EndStruct()
}

func (c Block_codec) Decode(d *codec.Decoder) interface{} {
	var x Block
	c.decode(d, &x)
	return x
}

func (c Block_codec) decode(d *codec.Decoder, x *Block) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			(ptr_BlockHeader_codec{}).decode(d, &x.Header)
		case 1:
			(ptr_BlockData_codec{}).decode(d, &x.Data)
		case 2:
			(ptr_BlockMetadata_codec{}).decode(d, &x.Metadata)
		default:
			d.UnknownField("Block", n)
		}
	}
}

func init() {
	codec.Register(Block{}, Block_codec{})
	codec.Register(&Block{}, ptr_Block_codec{})
}

type TxPvtDataMap_codec struct{}

func (c TxPvtDataMap_codec) Init() {}

func (c TxPvtDataMap_codec) Encode(e *codec.Encoder, x interface{}) { c.encode(e, x.(TxPvtDataMap)) }

func (c TxPvtDataMap_codec) encode(e *codec.Encoder, m TxPvtDataMap) {
	if m == nil {
		e.EncodeNil()
		return
	}
	e.StartList(2 * len(m))
	for k, v := range m {
		e.EncodeUint(k)
		(ptr_TxPvtData_codec{}).encode(e, v)
	}
}

func (c TxPvtDataMap_codec) Decode(d *codec.Decoder) interface{} {
	var x TxPvtDataMap
	c.decode(d, &x)
	return x
}

func (c TxPvtDataMap_codec) decode(d *codec.Decoder, p *TxPvtDataMap) {
	n2 := d.StartList()
	if n2 < 0 {
		return
	}
	n := n2 / 2
	m := make(TxPvtDataMap, n)
	var k uint64
	var v *TxPvtData
	for i := 0; i < n; i++ {
		k = d.DecodeUint()
		(ptr_TxPvtData_codec{}).decode(d, &v)
		m[k] = v
	}
	*p = m
}

func init() { codec.Register(TxPvtDataMap(nil), TxPvtDataMap_codec{}) }

type TxMissingPvtData_codec struct{}

func (c TxMissingPvtData_codec) Init() {}

func (c TxMissingPvtData_codec) Encode(e *codec.Encoder, x interface{}) {
	c.encode(e, x.(TxMissingPvtData))
}

func (c TxMissingPvtData_codec) encode(e *codec.Encoder, m TxMissingPvtData) {
	if m == nil {
		e.EncodeNil()
		return
	}
	e.StartList(2 * len(m))
	for k, v := range m {
		e.EncodeUint(k)
		(slice_ptr_MissingPvtData_codec{}).encode(e, v)
	}
}

func (c TxMissingPvtData_codec) Decode(d *codec.Decoder) interface{} {
	var x TxMissingPvtData
	c.decode(d, &x)
	return x
}

func (c TxMissingPvtData_codec) decode(d *codec.Decoder, p *TxMissingPvtData) {
	n2 := d.StartList()
	if n2 < 0 {
		return
	}
	n := n2 / 2
	m := make(TxMissingPvtData, n)
	var k uint64
	var v []*MissingPvtData
	for i := 0; i < n; i++ {
		k = d.DecodeUint()
		(slice_ptr_MissingPvtData_codec{}).decode(d, &v)
		m[k] = v
	}
	*p = m
}

func init() { codec.Register(TxMissingPvtData(nil), TxMissingPvtData_codec{}) }

// Fields of Envelope: Payload Signature

type ptr_Envelope_codec struct{}

func (ptr_Envelope_codec) Init() {}

func (c ptr_Envelope_codec) Encode(e *codec.Encoder, x interface{}) { c.encode(e, x.(*Envelope)) }

func (c ptr_Envelope_codec) encode(e *codec.Encoder, x *Envelope) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(Envelope_codec{}).encode(e, x)
}

func (c ptr_Envelope_codec) Decode(d *codec.Decoder) interface{} {
	var x *Envelope
	c.decode(d, &x)
	return x
}

func (c ptr_Envelope_codec) decode(d *codec.Decoder, p **Envelope) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*Envelope)
		return
	}
	var x Envelope
	d.StoreRef(&x)
	(Envelope_codec{}).decode(d, &x)
	*p = &x
}

type Envelope_codec struct{}

func (Envelope_codec) Init() {}

func (c Envelope_codec) Encode(e *codec.Encoder, x interface{}) {
	s := x.(Envelope)
	c.encode(e, &s)
}

func (c Envelope_codec) encode(e *codec.Encoder, x *Envelope) {
	e.StartStruct()
	if x.Payload != nil {
		e.EncodeUint(0)
		e.EncodeBytes(x.Payload)
	}
	if x.Signature != nil {
		e.EncodeUint(1)
		e.EncodeBytes(x.Signature)
	}
	e.EndStruct()
}

func (c Envelope_codec) Decode(d *codec.Decoder) interface{} {
	var x Envelope
	c.decode(d, &x)
	return x
}

func (c Envelope_codec) decode(d *codec.Decoder, x *Envelope) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Payload = d.DecodeBytes()
		case 1:
			x.Signature = d.DecodeBytes()
		default:
			d.UnknownField("Envelope", n)
		}
	}
}

func init() {
	codec.Register(Envelope{}, Envelope_codec{})
	codec.Register(&Envelope{}, ptr_Envelope_codec{})
}

// Fields of TxPvtReadWriteSet: DataModel NsPvtRwset

type ptr_TxPvtReadWriteSet_codec struct{}

func (ptr_TxPvtReadWriteSet_codec) Init() {}

func (c ptr_TxPvtReadWriteSet_codec) Encode(e *codec.Encoder, x interface{}) {
	c.encode(e, x.(*TxPvtReadWriteSet))
}

func (c ptr_TxPvtReadWriteSet_codec) encode(e *codec.Encoder, x *TxPvtReadWriteSet) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(TxPvtReadWriteSet_codec{}).encode(e, x)
}

func (c ptr_TxPvtReadWriteSet_codec) Decode(d *codec.Decoder) interface{} {
	var x *TxPvtReadWriteSet
	c.decode(d, &x)
	return x
}

func (c ptr_TxPvtReadWriteSet_codec) decode(d *codec.Decoder, p **TxPvtReadWriteSet) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*TxPvtReadWriteSet)
		return
	}
	var x TxPvtReadWriteSet
	d.StoreRef(&x)
	(TxPvtReadWriteSet_codec{}).decode(d, &x)
	*p = &x
}

type TxPvtReadWriteSet_codec struct{}

func (TxPvtReadWriteSet_codec) Init() {}

func (c TxPvtReadWriteSet_codec) Encode(e *codec.Encoder, x interface{}) {
	s := x.(TxPvtReadWriteSet)
	c.encode(e, &s)
}

func (c TxPvtReadWriteSet_codec) encode(e *codec.Encoder, x *TxPvtReadWriteSet) {
	e.StartStruct()
	if x.DataModel != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.DataModel))
	}
	if x.NsPvtRwset != nil {
		e.EncodeUint(1)
		(slice_ptr_NsPvtReadWriteSet_codec{}).encode(e, x.NsPvtRwset)
	}
	e.EndStruct()
}

func (c TxPvtReadWriteSet_codec) Decode(d *codec.Decoder) interface{} {
	var x TxPvtReadWriteSet
	c.decode(d, &x)
	return x
}

func (c TxPvtReadWriteSet_codec) decode(d *codec.Decoder, x *TxPvtReadWriteSet) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.DataModel = int32(d.DecodeInt())
		case 1:
			(slice_ptr_NsPvtReadWriteSet_codec{}).decode(d, &x.NsPvtRwset)
		default:
			d.UnknownField("TxPvtReadWriteSet", n)
		}
	}
}

func init() {
	codec.Register(TxPvtReadWriteSet{}, TxPvtReadWriteSet_codec{})
	codec.Register(&TxPvtReadWriteSet{}, ptr_TxPvtReadWriteSet_codec{})
}

type time_Time_codec struct{}

func (c time_Time_codec) Init() {}

func (c time_Time_codec) Encode(e *codec.Encoder, x interface{}) { c.encode(e, x.(time.Time)) }

func (c time_Time_codec) encode(e *codec.Encoder, m time.Time) {
	data, err := m.MarshalBinary()
	if err != nil {
		e.Fail(err)
	}
	e.EncodeBytes(data)
}

func (c time_Time_codec) Decode(d *codec.Decoder) interface{} {
	var x time.Time
	c.decode(d, &x)
	return x
}

func (c time_Time_codec) decode(d *codec.Decoder, p *time.Time) {
	data := d.DecodeBytes()
	if err := p.UnmarshalBinary(data); err != nil {
		d.Fail(err)
	}
}

func init() { codec.Register(*new(time.Time), time_Time_codec{}) }

// Fields of licensecheck_Match: Name Type Percent Start End IsURL

type ptr_licensecheck_Match_codec struct{}

func (ptr_licensecheck_Match_codec) Init() {}

func (c ptr_licensecheck_Match_codec) Encode(e *codec.Encoder, x interface{}) {
	c.encode(e, x.(*licensecheck.Match))
}

func (c ptr_licensecheck_Match_codec) encode(e *codec.Encoder, x *licensecheck.Match) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(licensecheck_Match_codec{}).encode(e, x)
}

func (c ptr_licensecheck_Match_codec) Decode(d *codec.Decoder) interface{} {
	var x *licensecheck.Match
	c.decode(d, &x)
	return x
}

func (c ptr_licensecheck_Match_codec) decode(d *codec.Decoder, p **licensecheck.Match) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*licensecheck.Match)
		return
	}
	var x licensecheck.Match
	d.StoreRef(&x)
	(licensecheck_Match_codec{}).decode(d, &x)
	*p = &x
}

type licensecheck_Match_codec struct{}

func (licensecheck_Match_codec) Init() {}

func (c licensecheck_Match_codec) Encode(e *codec.Encoder, x interface{}) {
	s := x.(licensecheck.Match)
	c.encode(e, &s)
}

func (c licensecheck_Match_codec) encode(e *codec.Encoder, x *licensecheck.Match) {
	e.StartStruct()
	if x.Name != "" {
		e.EncodeUint(0)
		e.EncodeString(x.Name)
	}
	if x.Type != 0 {
		e.EncodeUint(1)
		e.EncodeInt(int64(x.Type))
	}
	if x.Percent != 0 {
		e.EncodeUint(2)
		e.EncodeFloat(x.Percent)
	}
	if x.Start != 0 {
		e.EncodeUint(3)
		e.EncodeInt(int64(x.Start))
	}
	if x.End != 0 {
		e.EncodeUint(4)
		e.EncodeInt(int64(x.End))
	}
	if x.IsURL != false {
		e.EncodeUint(5)
		e.EncodeBool(x.IsURL)
	}
	e.EndStruct()
}

func (c licensecheck_Match_codec) Decode(d *codec.Decoder) interface{} {
	var x licensecheck.Match
	c.decode(d, &x)
	return x
}

func (c licensecheck_Match_codec) decode(d *codec.Decoder, x *licensecheck.Match) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Name = d.DecodeString()
		case 1:
			x.Type = licensecheck.Type(d.DecodeInt())
		case 2:
			x.Percent = d.DecodeFloat()
		case 3:
			x.Start = int(d.DecodeInt())
		case 4:
			x.End = int(d.DecodeInt())
		case 5:
			x.IsURL = d.DecodeBool()
		default:
			d.UnknownField("licensecheck.Match", n)
		}
	}
}

func init() {
	codec.Register(licensecheck.Match{}, licensecheck_Match_codec{})
	codec.Register(&licensecheck.Match{}, ptr_licensecheck_Match_codec{})
}

// Fields of BlockHeader: Number PreviousHash DataHash

type ptr_BlockHeader_codec struct{}

func (ptr_BlockHeader_codec) Init() {}

func (c ptr_BlockHeader_codec) Encode(e *codec.Encoder, x interface{}) { c.encode(e, x.(*BlockHeader)) }

func (c ptr_BlockHeader_codec) encode(e *codec.Encoder, x *BlockHeader) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(BlockHeader_codec{}).encode(e, x)
}

func (c ptr_BlockHeader_codec) Decode(d *codec.Decoder) interface{} {
	var x *BlockHeader
	c.decode(d, &x)
	return x
}

func (c ptr_BlockHeader_codec) decode(d *codec.Decoder, p **BlockHeader) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*BlockHeader)
		return
	}
	var x BlockHeader
	d.StoreRef(&x)
	(BlockHeader_codec{}).decode(d, &x)
	*p = &x
}

type BlockHeader_codec struct{}

func (BlockHeader_codec) Init() {}

func (c BlockHeader_codec) Encode(e *codec.Encoder, x interface{}) {
	s := x.(BlockHeader)
	c.encode(e, &s)
}

func (c BlockHeader_codec) encode(e *codec.Encoder, x *BlockHeader) {
	e.StartStruct()
	if x.Number != 0 {
		e.EncodeUint(0)
		e.EncodeUint(x.Number)
	}
	if x.PreviousHash != nil {
		e.EncodeUint(1)
		e.EncodeBytes(x.PreviousHash)
	}
	if x.DataHash != nil {
		e.EncodeUint(2)
		e.EncodeBytes(x.DataHash)
	}
	e.EndStruct()
}

func (c BlockHeader_codec) Decode(d *codec.Decoder) interface{} {
	var x BlockHeader
	c.decode(d, &x)
	return x
}

func (c BlockHeader_codec) decode(d *codec.Decoder, x *BlockHeader) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Number = d.DecodeUint()
		case 1:
			x.PreviousHash = d.DecodeBytes()
		case 2:
			x.DataHash = d.DecodeBytes()
		default:
			d.UnknownField("BlockHeader", n)
		}
	}
}

func init() {
	codec.Register(BlockHeader{}, BlockHeader_codec{})
	codec.Register(&BlockHeader{}, ptr_BlockHeader_codec{})
}

// Fields of BlockData: Data

type ptr_BlockData_codec struct{}

func (ptr_BlockData_codec) Init() {}

func (c ptr_BlockData_codec) Encode(e *codec.Encoder, x interface{}) { c.encode(e, x.(*BlockData)) }

func (c ptr_BlockData_codec) encode(e *codec.Encoder, x *BlockData) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(BlockData_codec{}).encode(e, x)
}

func (c ptr_BlockData_codec) Decode(d *codec.Decoder) interface{} {
	var x *BlockData
	c.decode(d, &x)
	return x
}

func (c ptr_BlockData_codec) decode(d *codec.Decoder, p **BlockData) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*BlockData)
		return
	}
	var x BlockData
	d.StoreRef(&x)
	(BlockData_codec{}).decode(d, &x)
	*p = &x
}

type BlockData_codec struct{}

func (BlockData_codec) Init() {}

func (c BlockData_codec) Encode(e *codec.Encoder, x interface{}) {
	s := x.(BlockData)
	c.encode(e, &s)
}

func (c BlockData_codec) encode(e *codec.Encoder, x *BlockData) {
	e.StartStruct()
	if x.Data != nil {
		e.EncodeUint(0)
		(slice_slice_uint8_codec{}).encode(e, x.Data)
	}
	e.EndStruct()
}

func (c BlockData_codec) Decode(d *codec.Decoder) interface{} {
	var x BlockData
	c.decode(d, &x)
	return x
}

func (c BlockData_codec) decode(d *codec.Decoder, x *BlockData) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			(slice_slice_uint8_codec{}).decode(d, &x.Data)
		default:
			d.UnknownField("BlockData", n)
		}
	}
}

func init() {
	codec.Register(BlockData{}, BlockData_codec{})
	codec.Register(&BlockData{}, ptr_BlockData_codec{})
}

// Fields of BlockMetadata: Metadata

type ptr_BlockMetadata_codec struct{}

func (ptr_BlockMetadata_codec) Init() {}

func (c ptr_BlockMetadata_codec) Encode(e *codec.Encoder, x interface{}) {
	c.encode(e, x.(*BlockMetadata))
}

func (c ptr_BlockMetadata_codec) encode(e *codec.Encoder, x *BlockMetadata) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(BlockMetadata_codec{}).encode(e, x)
}

func (c ptr_BlockMetadata_codec) Decode(d *codec.Decoder) interface{} {
	var x *BlockMetadata
	c.decode(d, &x)
	return x
}

func (c ptr_BlockMetadata_codec) decode(d *codec.Decoder, p **BlockMetadata) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*BlockMetadata)
		return
	}
	var x BlockMetadata
	d.StoreRef(&x)
	(BlockMetadata_codec{}).decode(d, &x)
	*p = &x
}

type BlockMetadata_codec struct{}

func (BlockMetadata_codec) Init() {}

func (c BlockMetadata_codec) Encode(e *codec.Encoder, x interface{}) {
	s := x.(BlockMetadata)
	c.encode(e, &s)
}

func (c BlockMetadata_codec) encode(e *codec.Encoder, x *BlockMetadata) {
	e.StartStruct()
	if x.Metadata != nil {
		e.EncodeUint(0)
		(slice_slice_uint8_codec{}).encode(e, x.Metadata)
	}
	e.EndStruct()
}

func (c BlockMetadata_codec) Decode(d *codec.Decoder) interface{} {
	var x BlockMetadata
	c.decode(d, &x)
	return x
}

func (c BlockMetadata_codec) decode(d *codec.Decoder, x *BlockMetadata) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			(slice_slice_uint8_codec{}).decode(d, &x.Metadata)
		default:
			d.UnknownField("BlockMetadata", n)
		}
	}
}

func init() {
	codec.Register(BlockMetadata{}, BlockMetadata_codec{})
	codec.Register(&BlockMetadata{}, ptr_BlockMetadata_codec{})
}

// Fields of TxPvtData: SeqInBlock WriteSet

type ptr_TxPvtData_codec struct{}

func (ptr_TxPvtData_codec) Init() {}

func (c ptr_TxPvtData_codec) Encode(e *codec.Encoder, x interface{}) { c.encode(e, x.(*TxPvtData)) }

func (c ptr_TxPvtData_codec) encode(e *codec.Encoder, x *TxPvtData) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(TxPvtData_codec{}).encode(e, x)
}

func (c ptr_TxPvtData_codec) Decode(d *codec.Decoder) interface{} {
	var x *TxPvtData
	c.decode(d, &x)
	return x
}

func (c ptr_TxPvtData_codec) decode(d *codec.Decoder, p **TxPvtData) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*TxPvtData)
		return
	}
	var x TxPvtData
	d.StoreRef(&x)
	(TxPvtData_codec{}).decode(d, &x)
	*p = &x
}

type TxPvtData_codec struct{}

func (TxPvtData_codec) Init() {}

func (c TxPvtData_codec) Encode(e *codec.Encoder, x interface{}) {
	s := x.(TxPvtData)
	c.encode(e, &s)
}

func (c TxPvtData_codec) encode(e *codec.Encoder, x *TxPvtData) {
	e.StartStruct()
	if x.SeqInBlock != 0 {
		e.EncodeUint(0)
		e.EncodeUint(x.SeqInBlock)
	}
	if x.WriteSet != nil {
		e.EncodeUint(1)
		(ptr_TxPvtReadWriteSet_codec{}).encode(e, x.WriteSet)
	}
	e.EndStruct()
}

func (c TxPvtData_codec) Decode(d *codec.Decoder) interface{} {
	var x TxPvtData
	c.decode(d, &x)
	return x
}

func (c TxPvtData_codec) decode(d *codec.Decoder, x *TxPvtData) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.SeqInBlock = d.DecodeUint()
		case 1:
			(ptr_TxPvtReadWriteSet_codec{}).decode(d, &x.WriteSet)
		default:
			d.UnknownField("TxPvtData", n)
		}
	}
}

func init() {
	codec.Register(TxPvtData{}, TxPvtData_codec{})
	codec.Register(&TxPvtData{}, ptr_TxPvtData_codec{})
}

type slice_ptr_MissingPvtData_codec struct{}

func (slice_ptr_MissingPvtData_codec) Init() {}

func (c slice_ptr_MissingPvtData_codec) Encode(e *codec.Encoder, x interface{}) {
	c.encode(e, x.([]*MissingPvtData))
}

func (c slice_ptr_MissingPvtData_codec) encode(e *codec.Encoder, s []*MissingPvtData) {
	if s == nil {
		e.EncodeNil()
		return
	}
	e.StartList(len(s))
	for _, x := range s {
		(ptr_MissingPvtData_codec{}).encode(e, x)
	}
}

func (c slice_ptr_MissingPvtData_codec) Decode(d *codec.Decoder) interface{} {
	var x []*MissingPvtData
	c.decode(d, &x)
	return x
}

func (c slice_ptr_MissingPvtData_codec) decode(d *codec.Decoder, p *[]*MissingPvtData) {
	n := d.StartList()
	if n < 0 {
		return
	}
	s := make([]*MissingPvtData, n)
	for i := 0; i < n; i++ {
		(ptr_MissingPvtData_codec{}).decode(d, &s[i])
	}
	*p = s
}

func init() {
	codec.Register([]*MissingPvtData(nil), slice_ptr_MissingPvtData_codec{})
}

type slice_ptr_NsPvtReadWriteSet_codec struct{}

func (slice_ptr_NsPvtReadWriteSet_codec) Init() {}

func (c slice_ptr_NsPvtReadWriteSet_codec) Encode(e *codec.Encoder, x interface{}) {
	c.encode(e, x.([]*NsPvtReadWriteSet))
}

func (c slice_ptr_NsPvtReadWriteSet_codec) encode(e *codec.Encoder, s []*NsPvtReadWriteSet) {
	if s == nil {
		e.EncodeNil()
		return
	}
	e.StartList(len(s))
	for _, x := range s {
		(ptr_NsPvtReadWriteSet_codec{}).encode(e, x)
	}
}

func (c slice_ptr_NsPvtReadWriteSet_codec) Decode(d *codec.Decoder) interface{} {
	var x []*NsPvtReadWriteSet
	c.decode(d, &x)
	return x
}

func (c slice_ptr_NsPvtReadWriteSet_codec) decode(d *codec.Decoder, p *[]*NsPvtReadWriteSet) {
	n := d.StartList()
	if n < 0 {
		return
	}
	s := make([]*NsPvtReadWriteSet, n)
	for i := 0; i < n; i++ {
		(ptr_NsPvtReadWriteSet_codec{}).decode(d, &s[i])
	}
	*p = s
}

func init() {
	codec.Register([]*NsPvtReadWriteSet(nil), slice_ptr_NsPvtReadWriteSet_codec{})
}

type slice_slice_uint8_codec struct{}

func (slice_slice_uint8_codec) Init() {}

func (c slice_slice_uint8_codec) Encode(e *codec.Encoder, x interface{}) { c.encode(e, x.([][]uint8)) }

func (c slice_slice_uint8_codec) encode(e *codec.Encoder, s [][]uint8) {
	if s == nil {
		e.EncodeNil()
		return
	}
	e.StartList(len(s))
	for _, x := range s {
		e.EncodeBytes(x)
	}
}

func (c slice_slice_uint8_codec) Decode(d *codec.Decoder) interface{} {
	var x [][]uint8
	c.decode(d, &x)
	return x
}

func (c slice_slice_uint8_codec) decode(d *codec.Decoder, p *[][]uint8) {
	n := d.StartList()
	if n < 0 {
		return
	}
	s := make([][]uint8, n)
	for i := 0; i < n; i++ {
		s[i] = d.DecodeBytes()
	}
	*p = s
}

func init() {
	codec.Register([][]uint8(nil), slice_slice_uint8_codec{})
}

// Fields of MissingPvtData: Namespace Collection IsEligible

type ptr_MissingPvtData_codec struct{}

func (ptr_MissingPvtData_codec) Init() {}

func (c ptr_MissingPvtData_codec) Encode(e *codec.Encoder, x interface{}) {
	c.encode(e, x.(*MissingPvtData))
}

func (c ptr_MissingPvtData_codec) encode(e *codec.Encoder, x *MissingPvtData) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(MissingPvtData_codec{}).encode(e, x)
}

func (c ptr_MissingPvtData_codec) Decode(d *codec.Decoder) interface{} {
	var x *MissingPvtData
	c.decode(d, &x)
	return x
}

func (c ptr_MissingPvtData_codec) decode(d *codec.Decoder, p **MissingPvtData) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*MissingPvtData)
		return
	}
	var x MissingPvtData
	d.StoreRef(&x)
	(MissingPvtData_codec{}).decode(d, &x)
	*p = &x
}

type MissingPvtData_codec struct{}

func (MissingPvtData_codec) Init() {}

func (c MissingPvtData_codec) Encode(e *codec.Encoder, x interface{}) {
	s := x.(MissingPvtData)
	c.encode(e, &s)
}

func (c MissingPvtData_codec) encode(e *codec.Encoder, x *MissingPvtData) {
	e.StartStruct()
	if x.Namespace != "" {
		e.EncodeUint(0)
		e.EncodeString(x.Namespace)
	}
	if x.Collection != "" {
		e.EncodeUint(1)
		e.EncodeString(x.Collection)
	}
	if x.IsEligible != false {
		e.EncodeUint(2)
		e.EncodeBool(x.IsEligible)
	}
	e.EndStruct()
}

func (c MissingPvtData_codec) Decode(d *codec.Decoder) interface{} {
	var x MissingPvtData
	c.decode(d, &x)
	return x
}

func (c MissingPvtData_codec) decode(d *codec.Decoder, x *MissingPvtData) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Namespace = d.DecodeString()
		case 1:
			x.Collection = d.DecodeString()
		case 2:
			x.IsEligible = d.DecodeBool()
		default:
			d.UnknownField("MissingPvtData", n)
		}
	}
}

func init() {
	codec.Register(MissingPvtData{}, MissingPvtData_codec{})
	codec.Register(&MissingPvtData{}, ptr_MissingPvtData_codec{})
}

// Fields of NsPvtReadWriteSet: Namespace CollectionPvtRwset

type ptr_NsPvtReadWriteSet_codec struct{}

func (ptr_NsPvtReadWriteSet_codec) Init() {}

func (c ptr_NsPvtReadWriteSet_codec) Encode(e *codec.Encoder, x interface{}) {
	c.encode(e, x.(*NsPvtReadWriteSet))
}

func (c ptr_NsPvtReadWriteSet_codec) encode(e *codec.Encoder, x *NsPvtReadWriteSet) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(NsPvtReadWriteSet_codec{}).encode(e, x)
}

func (c ptr_NsPvtReadWriteSet_codec) Decode(d *codec.Decoder) interface{} {
	var x *NsPvtReadWriteSet
	c.decode(d, &x)
	return x
}

func (c ptr_NsPvtReadWriteSet_codec) decode(d *codec.Decoder, p **NsPvtReadWriteSet) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*NsPvtReadWriteSet)
		return
	}
	var x NsPvtReadWriteSet
	d.StoreRef(&x)
	(NsPvtReadWriteSet_codec{}).decode(d, &x)
	*p = &x
}

type NsPvtReadWriteSet_codec struct{}

func (NsPvtReadWriteSet_codec) Init() {}

func (c NsPvtReadWriteSet_codec) Encode(e *codec.Encoder, x interface{}) {
	s := x.(NsPvtReadWriteSet)
	c.encode(e, &s)
}

func (c NsPvtReadWriteSet_codec) encode(e *codec.Encoder, x *NsPvtReadWriteSet) {
	e.StartStruct()
	if x.Namespace != "" {
		e.EncodeUint(0)
		e.EncodeString(x.Namespace)
	}
	if x.CollectionPvtRwset != nil {
		e.EncodeUint(1)
		(slice_ptr_CollectionPvtReadWriteSet_codec{}).encode(e, x.CollectionPvtRwset)
	}
	e.EndStruct()
}

func (c NsPvtReadWriteSet_codec) Decode(d *codec.Decoder) interface{} {
	var x NsPvtReadWriteSet
	c.decode(d, &x)
	return x
}

func (c NsPvtReadWriteSet_codec) decode(d *codec.Decoder, x *NsPvtReadWriteSet) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Namespace = d.DecodeString()
		case 1:
			(slice_ptr_CollectionPvtReadWriteSet_codec{}).decode(d, &x.CollectionPvtRwset)
		default:
			d.UnknownField("NsPvtReadWriteSet", n)
		}
	}
}

func init() {
	codec.Register(NsPvtReadWriteSet{}, NsPvtReadWriteSet_codec{})
	codec.Register(&NsPvtReadWriteSet{}, ptr_NsPvtReadWriteSet_codec{})
}

type slice_ptr_CollectionPvtReadWriteSet_codec struct{}

func (slice_ptr_CollectionPvtReadWriteSet_codec) Init() {}

func (c slice_ptr_CollectionPvtReadWriteSet_codec) Encode(e *codec.Encoder, x interface{}) {
	c.encode(e, x.([]*CollectionPvtReadWriteSet))
}

func (c slice_ptr_CollectionPvtReadWriteSet_codec) encode(e *codec.Encoder, s []*CollectionPvtReadWriteSet) {
	if s == nil {
		e.EncodeNil()
		return
	}
	e.StartList(len(s))
	for _, x := range s {
		(ptr_CollectionPvtReadWriteSet_codec{}).encode(e, x)
	}
}

func (c slice_ptr_CollectionPvtReadWriteSet_codec) Decode(d *codec.Decoder) interface{} {
	var x []*CollectionPvtReadWriteSet
	c.decode(d, &x)
	return x
}

func (c slice_ptr_CollectionPvtReadWriteSet_codec) decode(d *codec.Decoder, p *[]*CollectionPvtReadWriteSet) {
	n := d.StartList()
	if n < 0 {
		return
	}
	s := make([]*CollectionPvtReadWriteSet, n)
	for i := 0; i < n; i++ {
		(ptr_CollectionPvtReadWriteSet_codec{}).decode(d, &s[i])
	}
	*p = s
}

func init() {
	codec.Register([]*CollectionPvtReadWriteSet(nil), slice_ptr_CollectionPvtReadWriteSet_codec{})
}

// Fields of CollectionPvtReadWriteSet: CollectionName Rwset

type ptr_CollectionPvtReadWriteSet_codec struct{}

func (ptr_CollectionPvtReadWriteSet_codec) Init() {}

func (c ptr_CollectionPvtReadWriteSet_codec) Encode(e *codec.Encoder, x interface{}) {
	c.encode(e, x.(*CollectionPvtReadWriteSet))
}

func (c ptr_CollectionPvtReadWriteSet_codec) encode(e *codec.Encoder, x *CollectionPvtReadWriteSet) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(CollectionPvtReadWriteSet_codec{}).encode(e, x)
}

func (c ptr_CollectionPvtReadWriteSet_codec) Decode(d *codec.Decoder) interface{} {
	var x *CollectionPvtReadWriteSet
	c.decode(d, &x)
	return x
}

func (c ptr_CollectionPvtReadWriteSet_codec) decode(d *codec.Decoder, p **CollectionPvtReadWriteSet) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*CollectionPvtReadWriteSet)
		return
	}
	var x CollectionPvtReadWriteSet
	d.StoreRef(&x)
	(CollectionPvtReadWriteSet_codec{}).decode(d, &x)
	*p = &x
}

type CollectionPvtReadWriteSet_codec struct{}

func (CollectionPvtReadWriteSet_codec) Init() {}

func (c CollectionPvtReadWriteSet_codec) Encode(e *codec.Encoder, x interface{}) {
	s := x.(CollectionPvtReadWriteSet)
	c.encode(e, &s)
}

func (c CollectionPvtReadWriteSet_codec) encode(e *codec.Encoder, x *CollectionPvtReadWriteSet) {
	e.StartStruct()
	if x.CollectionName != "" {
		e.EncodeUint(0)
		e.EncodeString(x.CollectionName)
	}
	if x.Rwset != nil {
		e.EncodeUint(1)
		e.EncodeBytes(x.Rwset)
	}
	e.EndStruct()
}

func (c CollectionPvtReadWriteSet_codec) Decode(d *codec.Decoder) interface{} {
	var x CollectionPvtReadWriteSet
	c.decode(d, &x)
	return x
}

func (c CollectionPvtReadWriteSet_codec) decode(d *codec.Decoder, x *CollectionPvtReadWriteSet) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.CollectionName = d.DecodeString()
		case 1:
			x.Rwset = d.DecodeBytes()
		default:
			d.UnknownField("CollectionPvtReadWriteSet", n)
		}
	}
}

func init() {
	codec.Register(CollectionPvtReadWriteSet{}, CollectionPvtReadWriteSet_codec{})
	codec.Register(&CollectionPvtReadWriteSet{}, ptr_CollectionPvtReadWriteSet_codec{})
}
