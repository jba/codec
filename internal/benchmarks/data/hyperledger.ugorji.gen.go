// +build go1.6

// Code generated by codecgen - DO NOT EDIT.

package data

import (
	"errors"
	codec1978 "github.com/ugorji/go/codec"
	"runtime"
	"strconv"
)

const (
	// ----- content types ----
	codecSelferCcUTF88382 = 1
	codecSelferCcRAW8382  = 255
	// ----- value types used ----
	codecSelferValueTypeArray8382     = 10
	codecSelferValueTypeMap8382       = 9
	codecSelferValueTypeString8382    = 6
	codecSelferValueTypeInt8382       = 2
	codecSelferValueTypeUint8382      = 3
	codecSelferValueTypeFloat8382     = 4
	codecSelferValueTypeNil8382       = 1
	codecSelferBitsize8382            = uint8(32 << (^uint(0) >> 63))
	codecSelferDecContainerLenNil8382 = -2147483648
)

var (
	errCodecSelferOnlyMapOrArrayEncodeToStruct8382 = errors.New(`only encoded map or array can be decoded into a struct`)
)

type codecSelfer8382 struct{}

func codecSelfer8382False() bool { return false }
func codecSelfer8382True() bool  { return true }

func init() {
	if codec1978.GenVersion != 20 {
		_, file, _, _ := runtime.Caller(0)
		ver := strconv.FormatInt(int64(codec1978.GenVersion), 10)
		panic(errors.New("codecgen version mismatch: current: 20, need " + ver + ". Re-generate file: " + file))
	}
}

func (x submittedData) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encsubmittedData((submittedData)(x), e)
	} // end block: if x map == nil
}

func (x *submittedData) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	h.decsubmittedData((*submittedData)(x), d)
}

func (x *submittedLedgerData) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			z.EncWriteArrayElem()
			if x.Blocks == nil {
				r.EncodeNil()
			} else {
				h.encSlicePtrtoBlockAndPvtData(([]*BlockAndPvtData)(x.Blocks), e)
			} // end block: if x.Blocks slice == nil
			z.EncWriteArrayElem()
			if x.Txs == nil {
				r.EncodeNil()
			} else {
				h.encSlicePtrtotxAndPvtdata(([]*txAndPvtdata)(x.Txs), e)
			} // end block: if x.Txs slice == nil
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Blocks\"")
			} else {
				r.EncodeString(`Blocks`)
			}
			z.EncWriteMapElemValue()
			if x.Blocks == nil {
				r.EncodeNil()
			} else {
				h.encSlicePtrtoBlockAndPvtData(([]*BlockAndPvtData)(x.Blocks), e)
			} // end block: if x.Blocks slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Txs\"")
			} else {
				r.EncodeString(`Txs`)
			}
			z.EncWriteMapElemValue()
			if x.Txs == nil {
				r.EncodeNil()
			} else {
				h.encSlicePtrtotxAndPvtdata(([]*txAndPvtdata)(x.Txs), e)
			} // end block: if x.Txs slice == nil
			z.EncWriteMapEnd()
		}
	}
}

func (x *submittedLedgerData) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8382 {
		*(x) = submittedLedgerData{}
	} else if yyct2 == codecSelferValueTypeMap8382 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8382 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8382)
	}
}

func (x *submittedLedgerData) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Blocks":
			h.decSlicePtrtoBlockAndPvtData((*[]*BlockAndPvtData)(&x.Blocks), d)
		case "Txs":
			h.decSlicePtrtotxAndPvtdata((*[]*txAndPvtdata)(&x.Txs), d)
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *submittedLedgerData) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj8 int
	var yyb8 bool
	var yyhl8 bool = l >= 0
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	h.decSlicePtrtoBlockAndPvtData((*[]*BlockAndPvtData)(&x.Blocks), d)
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	h.decSlicePtrtotxAndPvtdata((*[]*txAndPvtdata)(&x.Txs), d)
	for {
		yyj8++
		if yyhl8 {
			yyb8 = yyj8 > l
		} else {
			yyb8 = z.DecCheckBreak()
		}
		if yyb8 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj8-1, "")
	}
}

func (x *submittedLedgerData) IsCodecEmpty() bool {
	return !(len(x.Blocks) != 0 || len(x.Txs) != 0 || false)
}

func (x *BlockAndPvtData) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn3 bool = x.Block == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(3)
			if yyn3 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyxt6 := z.Extension(x.Block); yyxt6 != nil {
					z.EncExtension(x.Block, yyxt6)
					x.Block.CodecEncodeSelf(e)
				}
			}
			z.EncWriteArrayElem()
			if yyxt7 := z.Extension(x.PvtData); yyxt7 != nil {
				z.EncExtension(x.PvtData, yyxt7)
				x.PvtData.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			if yyxt8 := z.Extension(x.MissingPvtData); yyxt8 != nil {
				z.EncExtension(x.MissingPvtData, yyxt8)
				x.MissingPvtData.CodecEncodeSelf(e)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(3)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Block\"")
			} else {
				r.EncodeString(`Block`)
			}
			z.EncWriteMapElemValue()
			if yyn3 {
				r.EncodeNil()
			} else {
				if yyxt9 := z.Extension(x.Block); yyxt9 != nil {
					z.EncExtension(x.Block, yyxt9)
					x.Block.CodecEncodeSelf(e)
				}
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"PvtData\"")
			} else {
				r.EncodeString(`PvtData`)
			}
			z.EncWriteMapElemValue()
			if yyxt10 := z.Extension(x.PvtData); yyxt10 != nil {
				z.EncExtension(x.PvtData, yyxt10)
				x.PvtData.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"MissingPvtData\"")
			} else {
				r.EncodeString(`MissingPvtData`)
			}
			z.EncWriteMapElemValue()
			if yyxt11 := z.Extension(x.MissingPvtData); yyxt11 != nil {
				z.EncExtension(x.MissingPvtData, yyxt11)
				x.MissingPvtData.CodecEncodeSelf(e)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *BlockAndPvtData) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8382 {
		*(x) = BlockAndPvtData{}
	} else if yyct2 == codecSelferValueTypeMap8382 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8382 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8382)
	}
}

func (x *BlockAndPvtData) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Block":
			if r.TryNil() {
				if x.Block != nil { // remove the if-true
					x.Block = nil
				}
			} else {
				if x.Block == nil {
					x.Block = new(Block)
				}
				if yyxt5 := z.Extension(x.Block); yyxt5 != nil {
					z.DecExtension(x.Block, yyxt5)
				} else {
					x.Block.CodecDecodeSelf(d)
				}
			}
		case "PvtData":
			if yyxt7 := z.Extension(x.PvtData); yyxt7 != nil {
				z.DecExtension(&x.PvtData, yyxt7)
			} else {
				x.PvtData.CodecDecodeSelf(d)
			}
		case "MissingPvtData":
			if yyxt9 := z.Extension(x.MissingPvtData); yyxt9 != nil {
				z.DecExtension(&x.MissingPvtData, yyxt9)
			} else {
				x.MissingPvtData.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *BlockAndPvtData) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj10 int
	var yyb10 bool
	var yyhl10 bool = l >= 0
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = z.DecCheckBreak()
	}
	if yyb10 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Block != nil { // remove the if-true
			x.Block = nil
		}
	} else {
		if x.Block == nil {
			x.Block = new(Block)
		}
		if yyxt12 := z.Extension(x.Block); yyxt12 != nil {
			z.DecExtension(x.Block, yyxt12)
		} else {
			x.Block.CodecDecodeSelf(d)
		}
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = z.DecCheckBreak()
	}
	if yyb10 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt14 := z.Extension(x.PvtData); yyxt14 != nil {
		z.DecExtension(&x.PvtData, yyxt14)
	} else {
		x.PvtData.CodecDecodeSelf(d)
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = z.DecCheckBreak()
	}
	if yyb10 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt16 := z.Extension(x.MissingPvtData); yyxt16 != nil {
		z.DecExtension(&x.MissingPvtData, yyxt16)
	} else {
		x.MissingPvtData.CodecDecodeSelf(d)
	}
	for {
		yyj10++
		if yyhl10 {
			yyb10 = yyj10 > l
		} else {
			yyb10 = z.DecCheckBreak()
		}
		if yyb10 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj10-1, "")
	}
}

func (x *BlockAndPvtData) IsCodecEmpty() bool {
	return !(len(x.PvtData) != 0 || len(x.MissingPvtData) != 0 || false)
}

func (x *TxPvtData) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn4 bool = x.WriteSet == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			z.EncWriteArrayElem()
			r.EncodeUint(uint64(x.SeqInBlock))
			if yyn4 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyxt6 := z.Extension(x.WriteSet); yyxt6 != nil {
					z.EncExtension(x.WriteSet, yyxt6)
					x.WriteSet.CodecEncodeSelf(e)
				}
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"SeqInBlock\"")
			} else {
				r.EncodeString(`SeqInBlock`)
			}
			z.EncWriteMapElemValue()
			r.EncodeUint(uint64(x.SeqInBlock))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"WriteSet\"")
			} else {
				r.EncodeString(`WriteSet`)
			}
			z.EncWriteMapElemValue()
			if yyn4 {
				r.EncodeNil()
			} else {
				if yyxt8 := z.Extension(x.WriteSet); yyxt8 != nil {
					z.EncExtension(x.WriteSet, yyxt8)
					x.WriteSet.CodecEncodeSelf(e)
				}
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *TxPvtData) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8382 {
		*(x) = TxPvtData{}
	} else if yyct2 == codecSelferValueTypeMap8382 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8382 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8382)
	}
}

func (x *TxPvtData) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "SeqInBlock":
			x.SeqInBlock = (uint64)(r.DecodeUint64())
		case "WriteSet":
			if r.TryNil() {
				if x.WriteSet != nil { // remove the if-true
					x.WriteSet = nil
				}
			} else {
				if x.WriteSet == nil {
					x.WriteSet = new(TxPvtReadWriteSet)
				}
				if yyxt6 := z.Extension(x.WriteSet); yyxt6 != nil {
					z.DecExtension(x.WriteSet, yyxt6)
				} else {
					x.WriteSet.CodecDecodeSelf(d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *TxPvtData) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj7 int
	var yyb7 bool
	var yyhl7 bool = l >= 0
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.SeqInBlock = (uint64)(r.DecodeUint64())
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.WriteSet != nil { // remove the if-true
			x.WriteSet = nil
		}
	} else {
		if x.WriteSet == nil {
			x.WriteSet = new(TxPvtReadWriteSet)
		}
		if yyxt10 := z.Extension(x.WriteSet); yyxt10 != nil {
			z.DecExtension(x.WriteSet, yyxt10)
		} else {
			x.WriteSet.CodecDecodeSelf(d)
		}
	}
	for {
		yyj7++
		if yyhl7 {
			yyb7 = yyj7 > l
		} else {
			yyb7 = z.DecCheckBreak()
		}
		if yyb7 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj7-1, "")
	}
}

func (x *TxPvtData) IsCodecEmpty() bool {
	return !(x.SeqInBlock != 0 || false)
}

func (x *TxPvtReadWriteSet) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.DataModel))
			z.EncWriteArrayElem()
			if x.NsPvtRwset == nil {
				r.EncodeNil()
			} else {
				h.encSlicePtrtoNsPvtReadWriteSet(([]*NsPvtReadWriteSet)(x.NsPvtRwset), e)
			} // end block: if x.NsPvtRwset slice == nil
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"DataModel\"")
			} else {
				r.EncodeString(`DataModel`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.DataModel))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"NsPvtRwset\"")
			} else {
				r.EncodeString(`NsPvtRwset`)
			}
			z.EncWriteMapElemValue()
			if x.NsPvtRwset == nil {
				r.EncodeNil()
			} else {
				h.encSlicePtrtoNsPvtReadWriteSet(([]*NsPvtReadWriteSet)(x.NsPvtRwset), e)
			} // end block: if x.NsPvtRwset slice == nil
			z.EncWriteMapEnd()
		}
	}
}

func (x *TxPvtReadWriteSet) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8382 {
		*(x) = TxPvtReadWriteSet{}
	} else if yyct2 == codecSelferValueTypeMap8382 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8382 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8382)
	}
}

func (x *TxPvtReadWriteSet) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "DataModel":
			x.DataModel = (int32)(z.C.IntV(r.DecodeInt64(), 32))
		case "NsPvtRwset":
			h.decSlicePtrtoNsPvtReadWriteSet((*[]*NsPvtReadWriteSet)(&x.NsPvtRwset), d)
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *TxPvtReadWriteSet) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj7 int
	var yyb7 bool
	var yyhl7 bool = l >= 0
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.DataModel = (int32)(z.C.IntV(r.DecodeInt64(), 32))
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	h.decSlicePtrtoNsPvtReadWriteSet((*[]*NsPvtReadWriteSet)(&x.NsPvtRwset), d)
	for {
		yyj7++
		if yyhl7 {
			yyb7 = yyj7 > l
		} else {
			yyb7 = z.DecCheckBreak()
		}
		if yyb7 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj7-1, "")
	}
}

func (x *TxPvtReadWriteSet) IsCodecEmpty() bool {
	return !(x.DataModel != 0 || len(x.NsPvtRwset) != 0 || false)
}

func (x *NsPvtReadWriteSet) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			z.EncWriteArrayElem()
			r.EncodeString(string(x.Namespace))
			z.EncWriteArrayElem()
			if x.CollectionPvtRwset == nil {
				r.EncodeNil()
			} else {
				h.encSlicePtrtoCollectionPvtReadWriteSet(([]*CollectionPvtReadWriteSet)(x.CollectionPvtRwset), e)
			} // end block: if x.CollectionPvtRwset slice == nil
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Namespace\"")
			} else {
				r.EncodeString(`Namespace`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.Namespace))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"CollectionPvtRwset\"")
			} else {
				r.EncodeString(`CollectionPvtRwset`)
			}
			z.EncWriteMapElemValue()
			if x.CollectionPvtRwset == nil {
				r.EncodeNil()
			} else {
				h.encSlicePtrtoCollectionPvtReadWriteSet(([]*CollectionPvtReadWriteSet)(x.CollectionPvtRwset), e)
			} // end block: if x.CollectionPvtRwset slice == nil
			z.EncWriteMapEnd()
		}
	}
}

func (x *NsPvtReadWriteSet) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8382 {
		*(x) = NsPvtReadWriteSet{}
	} else if yyct2 == codecSelferValueTypeMap8382 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8382 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8382)
	}
}

func (x *NsPvtReadWriteSet) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Namespace":
			x.Namespace = (string)(string(r.DecodeStringAsBytes()))
		case "CollectionPvtRwset":
			h.decSlicePtrtoCollectionPvtReadWriteSet((*[]*CollectionPvtReadWriteSet)(&x.CollectionPvtRwset), d)
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *NsPvtReadWriteSet) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj7 int
	var yyb7 bool
	var yyhl7 bool = l >= 0
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Namespace = (string)(string(r.DecodeStringAsBytes()))
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	h.decSlicePtrtoCollectionPvtReadWriteSet((*[]*CollectionPvtReadWriteSet)(&x.CollectionPvtRwset), d)
	for {
		yyj7++
		if yyhl7 {
			yyb7 = yyj7 > l
		} else {
			yyb7 = z.DecCheckBreak()
		}
		if yyb7 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj7-1, "")
	}
}

func (x *NsPvtReadWriteSet) IsCodecEmpty() bool {
	return !(x.Namespace != "" || len(x.CollectionPvtRwset) != 0 || false)
}

func (x *CollectionPvtReadWriteSet) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			z.EncWriteArrayElem()
			r.EncodeString(string(x.CollectionName))
			z.EncWriteArrayElem()
			if x.Rwset == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.Rwset))
			} // end block: if x.Rwset slice == nil
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"CollectionName\"")
			} else {
				r.EncodeString(`CollectionName`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.CollectionName))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Rwset\"")
			} else {
				r.EncodeString(`Rwset`)
			}
			z.EncWriteMapElemValue()
			if x.Rwset == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.Rwset))
			} // end block: if x.Rwset slice == nil
			z.EncWriteMapEnd()
		}
	}
}

func (x *CollectionPvtReadWriteSet) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8382 {
		*(x) = CollectionPvtReadWriteSet{}
	} else if yyct2 == codecSelferValueTypeMap8382 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8382 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8382)
	}
}

func (x *CollectionPvtReadWriteSet) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "CollectionName":
			x.CollectionName = (string)(string(r.DecodeStringAsBytes()))
		case "Rwset":
			x.Rwset = r.DecodeBytes(([]byte)(x.Rwset), false)
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *CollectionPvtReadWriteSet) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj7 int
	var yyb7 bool
	var yyhl7 bool = l >= 0
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.CollectionName = (string)(string(r.DecodeStringAsBytes()))
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Rwset = r.DecodeBytes(([]byte)(x.Rwset), false)
	for {
		yyj7++
		if yyhl7 {
			yyb7 = yyj7 > l
		} else {
			yyb7 = z.DecCheckBreak()
		}
		if yyb7 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj7-1, "")
	}
}

func (x *CollectionPvtReadWriteSet) IsCodecEmpty() bool {
	return !(x.CollectionName != "" || len(x.Rwset) != 0 || false)
}

func (x TxPvtDataMap) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encTxPvtDataMap((TxPvtDataMap)(x), e)
	} // end block: if x map == nil
}

func (x *TxPvtDataMap) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	h.decTxPvtDataMap((*TxPvtDataMap)(x), d)
}

func (x *Block) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn3 bool = x.Header == nil
		var yyn4 bool = x.Data == nil
		var yyn5 bool = x.Metadata == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(3)
			if yyn3 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyxt6 := z.Extension(x.Header); yyxt6 != nil {
					z.EncExtension(x.Header, yyxt6)
					x.Header.CodecEncodeSelf(e)
				}
			}
			if yyn4 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyxt7 := z.Extension(x.Data); yyxt7 != nil {
					z.EncExtension(x.Data, yyxt7)
					x.Data.CodecEncodeSelf(e)
				}
			}
			if yyn5 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyxt8 := z.Extension(x.Metadata); yyxt8 != nil {
					z.EncExtension(x.Metadata, yyxt8)
					x.Metadata.CodecEncodeSelf(e)
				}
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(3)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Header\"")
			} else {
				r.EncodeString(`Header`)
			}
			z.EncWriteMapElemValue()
			if yyn3 {
				r.EncodeNil()
			} else {
				if yyxt9 := z.Extension(x.Header); yyxt9 != nil {
					z.EncExtension(x.Header, yyxt9)
					x.Header.CodecEncodeSelf(e)
				}
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Data\"")
			} else {
				r.EncodeString(`Data`)
			}
			z.EncWriteMapElemValue()
			if yyn4 {
				r.EncodeNil()
			} else {
				if yyxt10 := z.Extension(x.Data); yyxt10 != nil {
					z.EncExtension(x.Data, yyxt10)
					x.Data.CodecEncodeSelf(e)
				}
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Metadata\"")
			} else {
				r.EncodeString(`Metadata`)
			}
			z.EncWriteMapElemValue()
			if yyn5 {
				r.EncodeNil()
			} else {
				if yyxt11 := z.Extension(x.Metadata); yyxt11 != nil {
					z.EncExtension(x.Metadata, yyxt11)
					x.Metadata.CodecEncodeSelf(e)
				}
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *Block) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8382 {
		*(x) = Block{}
	} else if yyct2 == codecSelferValueTypeMap8382 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8382 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8382)
	}
}

func (x *Block) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Header":
			if r.TryNil() {
				if x.Header != nil { // remove the if-true
					x.Header = nil
				}
			} else {
				if x.Header == nil {
					x.Header = new(BlockHeader)
				}
				if yyxt5 := z.Extension(x.Header); yyxt5 != nil {
					z.DecExtension(x.Header, yyxt5)
				} else {
					x.Header.CodecDecodeSelf(d)
				}
			}
		case "Data":
			if r.TryNil() {
				if x.Data != nil { // remove the if-true
					x.Data = nil
				}
			} else {
				if x.Data == nil {
					x.Data = new(BlockData)
				}
				if yyxt7 := z.Extension(x.Data); yyxt7 != nil {
					z.DecExtension(x.Data, yyxt7)
				} else {
					x.Data.CodecDecodeSelf(d)
				}
			}
		case "Metadata":
			if r.TryNil() {
				if x.Metadata != nil { // remove the if-true
					x.Metadata = nil
				}
			} else {
				if x.Metadata == nil {
					x.Metadata = new(BlockMetadata)
				}
				if yyxt9 := z.Extension(x.Metadata); yyxt9 != nil {
					z.DecExtension(x.Metadata, yyxt9)
				} else {
					x.Metadata.CodecDecodeSelf(d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Block) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj10 int
	var yyb10 bool
	var yyhl10 bool = l >= 0
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = z.DecCheckBreak()
	}
	if yyb10 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Header != nil { // remove the if-true
			x.Header = nil
		}
	} else {
		if x.Header == nil {
			x.Header = new(BlockHeader)
		}
		if yyxt12 := z.Extension(x.Header); yyxt12 != nil {
			z.DecExtension(x.Header, yyxt12)
		} else {
			x.Header.CodecDecodeSelf(d)
		}
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = z.DecCheckBreak()
	}
	if yyb10 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Data != nil { // remove the if-true
			x.Data = nil
		}
	} else {
		if x.Data == nil {
			x.Data = new(BlockData)
		}
		if yyxt14 := z.Extension(x.Data); yyxt14 != nil {
			z.DecExtension(x.Data, yyxt14)
		} else {
			x.Data.CodecDecodeSelf(d)
		}
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = z.DecCheckBreak()
	}
	if yyb10 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Metadata != nil { // remove the if-true
			x.Metadata = nil
		}
	} else {
		if x.Metadata == nil {
			x.Metadata = new(BlockMetadata)
		}
		if yyxt16 := z.Extension(x.Metadata); yyxt16 != nil {
			z.DecExtension(x.Metadata, yyxt16)
		} else {
			x.Metadata.CodecDecodeSelf(d)
		}
	}
	for {
		yyj10++
		if yyhl10 {
			yyb10 = yyj10 > l
		} else {
			yyb10 = z.DecCheckBreak()
		}
		if yyb10 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj10-1, "")
	}
}

func (x *Block) IsCodecEmpty() bool {
	return !(false)
}

func (x *BlockHeader) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(3)
			z.EncWriteArrayElem()
			r.EncodeUint(uint64(x.Number))
			z.EncWriteArrayElem()
			if x.PreviousHash == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.PreviousHash))
			} // end block: if x.PreviousHash slice == nil
			z.EncWriteArrayElem()
			if x.DataHash == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.DataHash))
			} // end block: if x.DataHash slice == nil
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(3)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Number\"")
			} else {
				r.EncodeString(`Number`)
			}
			z.EncWriteMapElemValue()
			r.EncodeUint(uint64(x.Number))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"PreviousHash\"")
			} else {
				r.EncodeString(`PreviousHash`)
			}
			z.EncWriteMapElemValue()
			if x.PreviousHash == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.PreviousHash))
			} // end block: if x.PreviousHash slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"DataHash\"")
			} else {
				r.EncodeString(`DataHash`)
			}
			z.EncWriteMapElemValue()
			if x.DataHash == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.DataHash))
			} // end block: if x.DataHash slice == nil
			z.EncWriteMapEnd()
		}
	}
}

func (x *BlockHeader) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8382 {
		*(x) = BlockHeader{}
	} else if yyct2 == codecSelferValueTypeMap8382 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8382 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8382)
	}
}

func (x *BlockHeader) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Number":
			x.Number = (uint64)(r.DecodeUint64())
		case "PreviousHash":
			x.PreviousHash = r.DecodeBytes(([]byte)(x.PreviousHash), false)
		case "DataHash":
			x.DataHash = r.DecodeBytes(([]byte)(x.DataHash), false)
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *BlockHeader) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj9 int
	var yyb9 bool
	var yyhl9 bool = l >= 0
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = z.DecCheckBreak()
	}
	if yyb9 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Number = (uint64)(r.DecodeUint64())
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = z.DecCheckBreak()
	}
	if yyb9 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.PreviousHash = r.DecodeBytes(([]byte)(x.PreviousHash), false)
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = z.DecCheckBreak()
	}
	if yyb9 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.DataHash = r.DecodeBytes(([]byte)(x.DataHash), false)
	for {
		yyj9++
		if yyhl9 {
			yyb9 = yyj9 > l
		} else {
			yyb9 = z.DecCheckBreak()
		}
		if yyb9 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj9-1, "")
	}
}

func (x *BlockHeader) IsCodecEmpty() bool {
	return !(x.Number != 0 || len(x.PreviousHash) != 0 || len(x.DataHash) != 0 || false)
}

func (x *BlockData) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			if x.Data == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceBytesV(x.Data, e)
			} // end block: if x.Data slice == nil
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Data\"")
			} else {
				r.EncodeString(`Data`)
			}
			z.EncWriteMapElemValue()
			if x.Data == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceBytesV(x.Data, e)
			} // end block: if x.Data slice == nil
			z.EncWriteMapEnd()
		}
	}
}

func (x *BlockData) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8382 {
		*(x) = BlockData{}
	} else if yyct2 == codecSelferValueTypeMap8382 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8382 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8382)
	}
}

func (x *BlockData) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Data":
			z.F.DecSliceBytesX(&x.Data, d)
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *BlockData) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	z.F.DecSliceBytesX(&x.Data, d)
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *BlockData) IsCodecEmpty() bool {
	return !(len(x.Data) != 0 || false)
}

func (x *BlockMetadata) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			if x.Metadata == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceBytesV(x.Metadata, e)
			} // end block: if x.Metadata slice == nil
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Metadata\"")
			} else {
				r.EncodeString(`Metadata`)
			}
			z.EncWriteMapElemValue()
			if x.Metadata == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceBytesV(x.Metadata, e)
			} // end block: if x.Metadata slice == nil
			z.EncWriteMapEnd()
		}
	}
}

func (x *BlockMetadata) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8382 {
		*(x) = BlockMetadata{}
	} else if yyct2 == codecSelferValueTypeMap8382 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8382 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8382)
	}
}

func (x *BlockMetadata) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Metadata":
			z.F.DecSliceBytesX(&x.Metadata, d)
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *BlockMetadata) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	z.F.DecSliceBytesX(&x.Metadata, d)
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *BlockMetadata) IsCodecEmpty() bool {
	return !(len(x.Metadata) != 0 || false)
}

func (x *txAndPvtdata) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn4 bool = x.Envelope == nil
		var yyn5 bool = x.Pvtws == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(3)
			z.EncWriteArrayElem()
			r.EncodeString(string(x.Txid))
			if yyn4 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyxt7 := z.Extension(x.Envelope); yyxt7 != nil {
					z.EncExtension(x.Envelope, yyxt7)
					x.Envelope.CodecEncodeSelf(e)
				}
			}
			if yyn5 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyxt8 := z.Extension(x.Pvtws); yyxt8 != nil {
					z.EncExtension(x.Pvtws, yyxt8)
				} else {
					x.Pvtws.CodecEncodeSelf(e)
				}
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(3)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Txid\"")
			} else {
				r.EncodeString(`Txid`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.Txid))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Envelope\"")
			} else {
				r.EncodeString(`Envelope`)
			}
			z.EncWriteMapElemValue()
			if yyn4 {
				r.EncodeNil()
			} else {
				if yyxt10 := z.Extension(x.Envelope); yyxt10 != nil {
					z.EncExtension(x.Envelope, yyxt10)
					x.Envelope.CodecEncodeSelf(e)
				}
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Pvtws\"")
			} else {
				r.EncodeString(`Pvtws`)
			}
			z.EncWriteMapElemValue()
			if yyn5 {
				r.EncodeNil()
			} else {
				if yyxt11 := z.Extension(x.Pvtws); yyxt11 != nil {
					z.EncExtension(x.Pvtws, yyxt11)
				} else {
					x.Pvtws.CodecEncodeSelf(e)
				}
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *txAndPvtdata) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8382 {
		*(x) = txAndPvtdata{}
	} else if yyct2 == codecSelferValueTypeMap8382 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8382 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8382)
	}
}

func (x *txAndPvtdata) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Txid":
			x.Txid = (string)(string(r.DecodeStringAsBytes()))
		case "Envelope":
			if r.TryNil() {
				if x.Envelope != nil { // remove the if-true
					x.Envelope = nil
				}
			} else {
				if x.Envelope == nil {
					x.Envelope = new(Envelope)
				}
				if yyxt6 := z.Extension(x.Envelope); yyxt6 != nil {
					z.DecExtension(x.Envelope, yyxt6)
				} else {
					x.Envelope.CodecDecodeSelf(d)
				}
			}
		case "Pvtws":
			if r.TryNil() {
				if x.Pvtws != nil { // remove the if-true
					x.Pvtws = nil
				}
			} else {
				if x.Pvtws == nil {
					x.Pvtws = new(TxPvtReadWriteSet)
				}
				if yyxt8 := z.Extension(x.Pvtws); yyxt8 != nil {
					z.DecExtension(x.Pvtws, yyxt8)
				} else {
					x.Pvtws.CodecDecodeSelf(d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *txAndPvtdata) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj9 int
	var yyb9 bool
	var yyhl9 bool = l >= 0
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = z.DecCheckBreak()
	}
	if yyb9 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Txid = (string)(string(r.DecodeStringAsBytes()))
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = z.DecCheckBreak()
	}
	if yyb9 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Envelope != nil { // remove the if-true
			x.Envelope = nil
		}
	} else {
		if x.Envelope == nil {
			x.Envelope = new(Envelope)
		}
		if yyxt12 := z.Extension(x.Envelope); yyxt12 != nil {
			z.DecExtension(x.Envelope, yyxt12)
		} else {
			x.Envelope.CodecDecodeSelf(d)
		}
	}
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = z.DecCheckBreak()
	}
	if yyb9 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Pvtws != nil { // remove the if-true
			x.Pvtws = nil
		}
	} else {
		if x.Pvtws == nil {
			x.Pvtws = new(TxPvtReadWriteSet)
		}
		if yyxt14 := z.Extension(x.Pvtws); yyxt14 != nil {
			z.DecExtension(x.Pvtws, yyxt14)
		} else {
			x.Pvtws.CodecDecodeSelf(d)
		}
	}
	for {
		yyj9++
		if yyhl9 {
			yyb9 = yyj9 > l
		} else {
			yyb9 = z.DecCheckBreak()
		}
		if yyb9 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj9-1, "")
	}
}

func (x *txAndPvtdata) IsCodecEmpty() bool {
	return !(x.Txid != "" || false)
}

func (x *Envelope) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			z.EncWriteArrayElem()
			if x.Payload == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.Payload))
			} // end block: if x.Payload slice == nil
			z.EncWriteArrayElem()
			if x.Signature == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.Signature))
			} // end block: if x.Signature slice == nil
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Payload\"")
			} else {
				r.EncodeString(`Payload`)
			}
			z.EncWriteMapElemValue()
			if x.Payload == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.Payload))
			} // end block: if x.Payload slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Signature\"")
			} else {
				r.EncodeString(`Signature`)
			}
			z.EncWriteMapElemValue()
			if x.Signature == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.Signature))
			} // end block: if x.Signature slice == nil
			z.EncWriteMapEnd()
		}
	}
}

func (x *Envelope) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8382 {
		*(x) = Envelope{}
	} else if yyct2 == codecSelferValueTypeMap8382 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8382 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8382)
	}
}

func (x *Envelope) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Payload":
			x.Payload = r.DecodeBytes(([]byte)(x.Payload), false)
		case "Signature":
			x.Signature = r.DecodeBytes(([]byte)(x.Signature), false)
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Envelope) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj8 int
	var yyb8 bool
	var yyhl8 bool = l >= 0
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Payload = r.DecodeBytes(([]byte)(x.Payload), false)
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Signature = r.DecodeBytes(([]byte)(x.Signature), false)
	for {
		yyj8++
		if yyhl8 {
			yyb8 = yyj8 > l
		} else {
			yyb8 = z.DecCheckBreak()
		}
		if yyb8 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj8-1, "")
	}
}

func (x *Envelope) IsCodecEmpty() bool {
	return !(len(x.Payload) != 0 || len(x.Signature) != 0 || false)
}

func (x TxMissingPvtData) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encTxMissingPvtData((TxMissingPvtData)(x), e)
	} // end block: if x map == nil
}

func (x *TxMissingPvtData) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	h.decTxMissingPvtData((*TxMissingPvtData)(x), d)
}

func (x *MissingPvtData) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(3)
			z.EncWriteArrayElem()
			r.EncodeString(string(x.Namespace))
			z.EncWriteArrayElem()
			r.EncodeString(string(x.Collection))
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.IsEligible))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(3)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Namespace\"")
			} else {
				r.EncodeString(`Namespace`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.Namespace))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Collection\"")
			} else {
				r.EncodeString(`Collection`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.Collection))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"IsEligible\"")
			} else {
				r.EncodeString(`IsEligible`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.IsEligible))
			z.EncWriteMapEnd()
		}
	}
}

func (x *MissingPvtData) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8382 {
		*(x) = MissingPvtData{}
	} else if yyct2 == codecSelferValueTypeMap8382 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8382 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8382)
	}
}

func (x *MissingPvtData) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Namespace":
			x.Namespace = (string)(string(r.DecodeStringAsBytes()))
		case "Collection":
			x.Collection = (string)(string(r.DecodeStringAsBytes()))
		case "IsEligible":
			x.IsEligible = (bool)(r.DecodeBool())
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *MissingPvtData) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj7 int
	var yyb7 bool
	var yyhl7 bool = l >= 0
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Namespace = (string)(string(r.DecodeStringAsBytes()))
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Collection = (string)(string(r.DecodeStringAsBytes()))
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.IsEligible = (bool)(r.DecodeBool())
	for {
		yyj7++
		if yyhl7 {
			yyb7 = yyj7 > l
		} else {
			yyb7 = z.DecCheckBreak()
		}
		if yyb7 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj7-1, "")
	}
}

func (x *MissingPvtData) IsCodecEmpty() bool {
	return !(x.Namespace != "" || x.Collection != "" || bool(x.IsEligible) || false)
}

func (x codecSelfer8382) encsubmittedData(v submittedData, e *codec1978.Encoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteMapStart(len(v))
	for yyk1, yyv1 := range v {
		z.EncWriteMapElemKey()
		r.EncodeString(string(yyk1))
		z.EncWriteMapElemValue()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			if yyxt3 := z.Extension(yyv1); yyxt3 != nil {
				z.EncExtension(yyv1, yyxt3)
			} else {
				yyv1.CodecEncodeSelf(e)
			}
		}
	}
	z.EncWriteMapEnd()
}

func (x codecSelfer8382) decsubmittedData(v *submittedData, d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyl1 := z.DecReadMapStart()
	if yyl1 == codecSelferDecContainerLenNil8382 {
		*v = nil
	} else {
		if yyv1 == nil {
			yyrl1 := z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 24)
			yyv1 = make(map[string]*submittedLedgerData, yyrl1)
			*v = yyv1
		}
		var yymk1 string
		var yymv1 *submittedLedgerData
		var yymg1, yymdn1, yyms1, yymok1 bool
		if z.DecBasicHandle().MapValueReset {
			yymg1 = true
		}
		if yyl1 != 0 {
			yyhl1 := yyl1 > 0
			for yyj1 := 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ {
				z.DecReadMapElemKey()
				yymk1 = (string)(string(r.DecodeStringAsBytes()))
				yyms1 = true
				if yymg1 {
					yymv1, yymok1 = yyv1[yymk1]
					if yymok1 {
						yyms1 = false
					}
				} else {
					yymv1 = nil
				}
				z.DecReadMapElemValue()
				yymdn1 = false
				if r.TryNil() {
					yymdn1 = true
				} else {
					if yymv1 == nil {
						yymv1 = new(submittedLedgerData)
					}
					if yyxt4 := z.Extension(yymv1); yyxt4 != nil {
						z.DecExtension(yymv1, yyxt4)
					} else {
						yymv1.CodecDecodeSelf(d)
					}
				}
				if yymdn1 {
					yyv1[yymk1] = nil
				} else if yyms1 && yyv1 != nil {
					yyv1[yymk1] = yymv1
				}
			}
		} // else len==0: leave as-is (do not clear map entries)
		z.DecReadMapEnd()
	}
}

func (x codecSelfer8382) encSlicePtrtoBlockAndPvtData(v []*BlockAndPvtData, e *codec1978.Encoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			if yyxt2 := z.Extension(yyv1); yyxt2 != nil {
				z.EncExtension(yyv1, yyxt2)
			} else {
				yyv1.CodecEncodeSelf(e)
			}
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer8382) decSlicePtrtoBlockAndPvtData(v *[]*BlockAndPvtData, d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*BlockAndPvtData{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*BlockAndPvtData, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*BlockAndPvtData, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(BlockAndPvtData)
					}
					if yyxt3 := z.Extension(yyv1[yyj1]); yyxt3 != nil {
						z.DecExtension(yyv1[yyj1], yyxt3)
					} else {
						yyv1[yyj1].CodecDecodeSelf(d)
					}
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*BlockAndPvtData, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer8382) encSlicePtrtotxAndPvtdata(v []*txAndPvtdata, e *codec1978.Encoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			if yyxt2 := z.Extension(yyv1); yyxt2 != nil {
				z.EncExtension(yyv1, yyxt2)
			} else {
				yyv1.CodecEncodeSelf(e)
			}
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer8382) decSlicePtrtotxAndPvtdata(v *[]*txAndPvtdata, d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*txAndPvtdata{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*txAndPvtdata, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*txAndPvtdata, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(txAndPvtdata)
					}
					if yyxt3 := z.Extension(yyv1[yyj1]); yyxt3 != nil {
						z.DecExtension(yyv1[yyj1], yyxt3)
					} else {
						yyv1[yyj1].CodecDecodeSelf(d)
					}
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*txAndPvtdata, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer8382) encSlicePtrtoNsPvtReadWriteSet(v []*NsPvtReadWriteSet, e *codec1978.Encoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			if yyxt2 := z.Extension(yyv1); yyxt2 != nil {
				z.EncExtension(yyv1, yyxt2)
			} else {
				yyv1.CodecEncodeSelf(e)
			}
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer8382) decSlicePtrtoNsPvtReadWriteSet(v *[]*NsPvtReadWriteSet, d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*NsPvtReadWriteSet{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*NsPvtReadWriteSet, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*NsPvtReadWriteSet, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(NsPvtReadWriteSet)
					}
					if yyxt3 := z.Extension(yyv1[yyj1]); yyxt3 != nil {
						z.DecExtension(yyv1[yyj1], yyxt3)
					} else {
						yyv1[yyj1].CodecDecodeSelf(d)
					}
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*NsPvtReadWriteSet, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer8382) encSlicePtrtoCollectionPvtReadWriteSet(v []*CollectionPvtReadWriteSet, e *codec1978.Encoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			if yyxt2 := z.Extension(yyv1); yyxt2 != nil {
				z.EncExtension(yyv1, yyxt2)
			} else {
				yyv1.CodecEncodeSelf(e)
			}
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer8382) decSlicePtrtoCollectionPvtReadWriteSet(v *[]*CollectionPvtReadWriteSet, d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*CollectionPvtReadWriteSet{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*CollectionPvtReadWriteSet, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*CollectionPvtReadWriteSet, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(CollectionPvtReadWriteSet)
					}
					if yyxt3 := z.Extension(yyv1[yyj1]); yyxt3 != nil {
						z.DecExtension(yyv1[yyj1], yyxt3)
					} else {
						yyv1[yyj1].CodecDecodeSelf(d)
					}
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*CollectionPvtReadWriteSet, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer8382) encTxPvtDataMap(v TxPvtDataMap, e *codec1978.Encoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteMapStart(len(v))
	for yyk1, yyv1 := range v {
		z.EncWriteMapElemKey()
		r.EncodeUint(uint64(yyk1))
		z.EncWriteMapElemValue()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			if yyxt3 := z.Extension(yyv1); yyxt3 != nil {
				z.EncExtension(yyv1, yyxt3)
			} else {
				yyv1.CodecEncodeSelf(e)
			}
		}
	}
	z.EncWriteMapEnd()
}

func (x codecSelfer8382) decTxPvtDataMap(v *TxPvtDataMap, d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyl1 := z.DecReadMapStart()
	if yyl1 == codecSelferDecContainerLenNil8382 {
		*v = nil
	} else {
		if yyv1 == nil {
			yyrl1 := z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 16)
			yyv1 = make(map[uint64]*TxPvtData, yyrl1)
			*v = yyv1
		}
		var yymk1 uint64
		var yymv1 *TxPvtData
		var yymg1, yymdn1, yyms1, yymok1 bool
		if z.DecBasicHandle().MapValueReset {
			yymg1 = true
		}
		if yyl1 != 0 {
			yyhl1 := yyl1 > 0
			for yyj1 := 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ {
				z.DecReadMapElemKey()
				yymk1 = (uint64)(r.DecodeUint64())
				yyms1 = true
				if yymg1 {
					yymv1, yymok1 = yyv1[yymk1]
					if yymok1 {
						yyms1 = false
					}
				} else {
					yymv1 = nil
				}
				z.DecReadMapElemValue()
				yymdn1 = false
				if r.TryNil() {
					yymdn1 = true
				} else {
					if yymv1 == nil {
						yymv1 = new(TxPvtData)
					}
					if yyxt4 := z.Extension(yymv1); yyxt4 != nil {
						z.DecExtension(yymv1, yyxt4)
					} else {
						yymv1.CodecDecodeSelf(d)
					}
				}
				if yymdn1 {
					yyv1[yymk1] = nil
				} else if yyms1 && yyv1 != nil {
					yyv1[yymk1] = yymv1
				}
			}
		} // else len==0: leave as-is (do not clear map entries)
		z.DecReadMapEnd()
	}
}

func (x codecSelfer8382) encTxMissingPvtData(v TxMissingPvtData, e *codec1978.Encoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteMapStart(len(v))
	for yyk1, yyv1 := range v {
		z.EncWriteMapElemKey()
		r.EncodeUint(uint64(yyk1))
		z.EncWriteMapElemValue()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			h.encSlicePtrtoMissingPvtData(([]*MissingPvtData)(yyv1), e)
		} // end block: if yyv1 slice == nil
	}
	z.EncWriteMapEnd()
}

func (x codecSelfer8382) decTxMissingPvtData(v *TxMissingPvtData, d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyl1 := z.DecReadMapStart()
	if yyl1 == codecSelferDecContainerLenNil8382 {
		*v = nil
	} else {
		if yyv1 == nil {
			yyrl1 := z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 32)
			yyv1 = make(map[uint64][]*MissingPvtData, yyrl1)
			*v = yyv1
		}
		var yymk1 uint64
		var yymv1 []*MissingPvtData
		var yymg1, yymdn1 bool
		if z.DecBasicHandle().MapValueReset {
			yymg1 = true
		}
		if yyl1 != 0 {
			yyhl1 := yyl1 > 0
			for yyj1 := 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ {
				z.DecReadMapElemKey()
				yymk1 = (uint64)(r.DecodeUint64())
				if yymg1 {
					yymv1 = yyv1[yymk1]
				} else {
					yymv1 = nil
				}
				z.DecReadMapElemValue()
				yymdn1 = false
				h.decSlicePtrtoMissingPvtData((*[]*MissingPvtData)(&yymv1), d)
				if yymdn1 {
					yyv1[yymk1] = nil
				} else if yyv1 != nil {
					yyv1[yymk1] = yymv1
				}
			}
		} // else len==0: leave as-is (do not clear map entries)
		z.DecReadMapEnd()
	}
}

func (x codecSelfer8382) encSlicePtrtoMissingPvtData(v []*MissingPvtData, e *codec1978.Encoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			if yyxt2 := z.Extension(yyv1); yyxt2 != nil {
				z.EncExtension(yyv1, yyxt2)
			} else {
				yyv1.CodecEncodeSelf(e)
			}
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer8382) decSlicePtrtoMissingPvtData(v *[]*MissingPvtData, d *codec1978.Decoder) {
	var h codecSelfer8382
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*MissingPvtData{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*MissingPvtData, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*MissingPvtData, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(MissingPvtData)
					}
					if yyxt3 := z.Extension(yyv1[yyj1]); yyxt3 != nil {
						z.DecExtension(yyv1[yyj1], yyxt3)
					} else {
						yyv1[yyj1].CodecDecodeSelf(d)
					}
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*MissingPvtData, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}
