// Code generated by the codec package. DO NOT EDIT.

package data

import (
	"github.com/jba/codec/codecapi"
	"go/ast"
	"go/token"
)

// Fields of ast_ArrayType: Lbrack Len Elt

type ptr_ast_ArrayType_codec struct{}

func (ptr_ast_ArrayType_codec) Init() {}

func (c ptr_ast_ArrayType_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.ArrayType))
}

func (c ptr_ast_ArrayType_codec) encode(e *codecapi.Encoder, x *ast.ArrayType) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_ArrayType_codec{}).encode(e, x)
}

func (c ptr_ast_ArrayType_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.ArrayType
	c.decode(d, &x)
	return x
}

func (c ptr_ast_ArrayType_codec) decode(d *codecapi.Decoder, p **ast.ArrayType) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.ArrayType)
		return
	}
	var x ast.ArrayType
	d.StoreRef(&x)
	(ast_ArrayType_codec{}).decode(d, &x)
	*p = &x
}

type ast_ArrayType_codec struct{}

func (ast_ArrayType_codec) Init() {}

func (c ast_ArrayType_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.ArrayType)
	c.encode(e, &s)
}

func (c ast_ArrayType_codec) encode(e *codecapi.Encoder, x *ast.ArrayType) {
	e.StartStruct()
	if x.Lbrack != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.Lbrack))
	}
	if x.Len != nil {
		e.EncodeUint(1)
		e.EncodeAny(x.Len)
	}
	if x.Elt != nil {
		e.EncodeUint(2)
		e.EncodeAny(x.Elt)
	}
	e.EndStruct()
}

func (c ast_ArrayType_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.ArrayType
	c.decode(d, &x)
	return x
}

func (c ast_ArrayType_codec) decode(d *codecapi.Decoder, x *ast.ArrayType) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Lbrack = token.Pos(d.DecodeInt())
		case 1:
			x.Len = d.DecodeAny().(ast.Expr)
		case 2:
			x.Elt = d.DecodeAny().(ast.Expr)
		default:
			d.UnknownField("ast.ArrayType", n)
		}
	}
}

func init() {
	codecapi.Register(ast.ArrayType{}, ast_ArrayType_codec{})
	codecapi.Register(&ast.ArrayType{}, ptr_ast_ArrayType_codec{})
}

// Fields of ast_AssignStmt: Lhs TokPos Tok Rhs

type ptr_ast_AssignStmt_codec struct{}

func (ptr_ast_AssignStmt_codec) Init() {}

func (c ptr_ast_AssignStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.AssignStmt))
}

func (c ptr_ast_AssignStmt_codec) encode(e *codecapi.Encoder, x *ast.AssignStmt) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_AssignStmt_codec{}).encode(e, x)
}

func (c ptr_ast_AssignStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.AssignStmt
	c.decode(d, &x)
	return x
}

func (c ptr_ast_AssignStmt_codec) decode(d *codecapi.Decoder, p **ast.AssignStmt) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.AssignStmt)
		return
	}
	var x ast.AssignStmt
	d.StoreRef(&x)
	(ast_AssignStmt_codec{}).decode(d, &x)
	*p = &x
}

type ast_AssignStmt_codec struct{}

func (ast_AssignStmt_codec) Init() {}

func (c ast_AssignStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.AssignStmt)
	c.encode(e, &s)
}

func (c ast_AssignStmt_codec) encode(e *codecapi.Encoder, x *ast.AssignStmt) {
	e.StartStruct()
	if x.Lhs != nil {
		e.EncodeUint(0)
		(slice_ast_Expr_codec{}).encode(e, x.Lhs)
	}
	if x.TokPos != 0 {
		e.EncodeUint(1)
		e.EncodeInt(int64(x.TokPos))
	}
	if x.Tok != 0 {
		e.EncodeUint(2)
		e.EncodeInt(int64(x.Tok))
	}
	if x.Rhs != nil {
		e.EncodeUint(3)
		(slice_ast_Expr_codec{}).encode(e, x.Rhs)
	}
	e.EndStruct()
}

func (c ast_AssignStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.AssignStmt
	c.decode(d, &x)
	return x
}

func (c ast_AssignStmt_codec) decode(d *codecapi.Decoder, x *ast.AssignStmt) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			(slice_ast_Expr_codec{}).decode(d, &x.Lhs)
		case 1:
			x.TokPos = token.Pos(d.DecodeInt())
		case 2:
			x.Tok = token.Token(d.DecodeInt())
		case 3:
			(slice_ast_Expr_codec{}).decode(d, &x.Rhs)
		default:
			d.UnknownField("ast.AssignStmt", n)
		}
	}
}

func init() {
	codecapi.Register(ast.AssignStmt{}, ast_AssignStmt_codec{})
	codecapi.Register(&ast.AssignStmt{}, ptr_ast_AssignStmt_codec{})
}

// Fields of ast_BadDecl: From To

type ptr_ast_BadDecl_codec struct{}

func (ptr_ast_BadDecl_codec) Init() {}

func (c ptr_ast_BadDecl_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.BadDecl))
}

func (c ptr_ast_BadDecl_codec) encode(e *codecapi.Encoder, x *ast.BadDecl) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_BadDecl_codec{}).encode(e, x)
}

func (c ptr_ast_BadDecl_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.BadDecl
	c.decode(d, &x)
	return x
}

func (c ptr_ast_BadDecl_codec) decode(d *codecapi.Decoder, p **ast.BadDecl) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.BadDecl)
		return
	}
	var x ast.BadDecl
	d.StoreRef(&x)
	(ast_BadDecl_codec{}).decode(d, &x)
	*p = &x
}

type ast_BadDecl_codec struct{}

func (ast_BadDecl_codec) Init() {}

func (c ast_BadDecl_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.BadDecl)
	c.encode(e, &s)
}

func (c ast_BadDecl_codec) encode(e *codecapi.Encoder, x *ast.BadDecl) {
	e.StartStruct()
	if x.From != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.From))
	}
	if x.To != 0 {
		e.EncodeUint(1)
		e.EncodeInt(int64(x.To))
	}
	e.EndStruct()
}

func (c ast_BadDecl_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.BadDecl
	c.decode(d, &x)
	return x
}

func (c ast_BadDecl_codec) decode(d *codecapi.Decoder, x *ast.BadDecl) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.From = token.Pos(d.DecodeInt())
		case 1:
			x.To = token.Pos(d.DecodeInt())
		default:
			d.UnknownField("ast.BadDecl", n)
		}
	}
}

func init() {
	codecapi.Register(ast.BadDecl{}, ast_BadDecl_codec{})
	codecapi.Register(&ast.BadDecl{}, ptr_ast_BadDecl_codec{})
}

// Fields of ast_BadExpr: From To

type ptr_ast_BadExpr_codec struct{}

func (ptr_ast_BadExpr_codec) Init() {}

func (c ptr_ast_BadExpr_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.BadExpr))
}

func (c ptr_ast_BadExpr_codec) encode(e *codecapi.Encoder, x *ast.BadExpr) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_BadExpr_codec{}).encode(e, x)
}

func (c ptr_ast_BadExpr_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.BadExpr
	c.decode(d, &x)
	return x
}

func (c ptr_ast_BadExpr_codec) decode(d *codecapi.Decoder, p **ast.BadExpr) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.BadExpr)
		return
	}
	var x ast.BadExpr
	d.StoreRef(&x)
	(ast_BadExpr_codec{}).decode(d, &x)
	*p = &x
}

type ast_BadExpr_codec struct{}

func (ast_BadExpr_codec) Init() {}

func (c ast_BadExpr_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.BadExpr)
	c.encode(e, &s)
}

func (c ast_BadExpr_codec) encode(e *codecapi.Encoder, x *ast.BadExpr) {
	e.StartStruct()
	if x.From != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.From))
	}
	if x.To != 0 {
		e.EncodeUint(1)
		e.EncodeInt(int64(x.To))
	}
	e.EndStruct()
}

func (c ast_BadExpr_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.BadExpr
	c.decode(d, &x)
	return x
}

func (c ast_BadExpr_codec) decode(d *codecapi.Decoder, x *ast.BadExpr) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.From = token.Pos(d.DecodeInt())
		case 1:
			x.To = token.Pos(d.DecodeInt())
		default:
			d.UnknownField("ast.BadExpr", n)
		}
	}
}

func init() {
	codecapi.Register(ast.BadExpr{}, ast_BadExpr_codec{})
	codecapi.Register(&ast.BadExpr{}, ptr_ast_BadExpr_codec{})
}

// Fields of ast_BadStmt: From To

type ptr_ast_BadStmt_codec struct{}

func (ptr_ast_BadStmt_codec) Init() {}

func (c ptr_ast_BadStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.BadStmt))
}

func (c ptr_ast_BadStmt_codec) encode(e *codecapi.Encoder, x *ast.BadStmt) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_BadStmt_codec{}).encode(e, x)
}

func (c ptr_ast_BadStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.BadStmt
	c.decode(d, &x)
	return x
}

func (c ptr_ast_BadStmt_codec) decode(d *codecapi.Decoder, p **ast.BadStmt) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.BadStmt)
		return
	}
	var x ast.BadStmt
	d.StoreRef(&x)
	(ast_BadStmt_codec{}).decode(d, &x)
	*p = &x
}

type ast_BadStmt_codec struct{}

func (ast_BadStmt_codec) Init() {}

func (c ast_BadStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.BadStmt)
	c.encode(e, &s)
}

func (c ast_BadStmt_codec) encode(e *codecapi.Encoder, x *ast.BadStmt) {
	e.StartStruct()
	if x.From != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.From))
	}
	if x.To != 0 {
		e.EncodeUint(1)
		e.EncodeInt(int64(x.To))
	}
	e.EndStruct()
}

func (c ast_BadStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.BadStmt
	c.decode(d, &x)
	return x
}

func (c ast_BadStmt_codec) decode(d *codecapi.Decoder, x *ast.BadStmt) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.From = token.Pos(d.DecodeInt())
		case 1:
			x.To = token.Pos(d.DecodeInt())
		default:
			d.UnknownField("ast.BadStmt", n)
		}
	}
}

func init() {
	codecapi.Register(ast.BadStmt{}, ast_BadStmt_codec{})
	codecapi.Register(&ast.BadStmt{}, ptr_ast_BadStmt_codec{})
}

// Fields of ast_BasicLit: ValuePos Kind Value

type ptr_ast_BasicLit_codec struct{}

func (ptr_ast_BasicLit_codec) Init() {}

func (c ptr_ast_BasicLit_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.BasicLit))
}

func (c ptr_ast_BasicLit_codec) encode(e *codecapi.Encoder, x *ast.BasicLit) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_BasicLit_codec{}).encode(e, x)
}

func (c ptr_ast_BasicLit_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.BasicLit
	c.decode(d, &x)
	return x
}

func (c ptr_ast_BasicLit_codec) decode(d *codecapi.Decoder, p **ast.BasicLit) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.BasicLit)
		return
	}
	var x ast.BasicLit
	d.StoreRef(&x)
	(ast_BasicLit_codec{}).decode(d, &x)
	*p = &x
}

type ast_BasicLit_codec struct{}

func (ast_BasicLit_codec) Init() {}

func (c ast_BasicLit_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.BasicLit)
	c.encode(e, &s)
}

func (c ast_BasicLit_codec) encode(e *codecapi.Encoder, x *ast.BasicLit) {
	e.StartStruct()
	if x.ValuePos != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.ValuePos))
	}
	if x.Kind != 0 {
		e.EncodeUint(1)
		e.EncodeInt(int64(x.Kind))
	}
	if x.Value != "" {
		e.EncodeUint(2)
		e.EncodeString(x.Value)
	}
	e.EndStruct()
}

func (c ast_BasicLit_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.BasicLit
	c.decode(d, &x)
	return x
}

func (c ast_BasicLit_codec) decode(d *codecapi.Decoder, x *ast.BasicLit) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.ValuePos = token.Pos(d.DecodeInt())
		case 1:
			x.Kind = token.Token(d.DecodeInt())
		case 2:
			x.Value = d.DecodeString()
		default:
			d.UnknownField("ast.BasicLit", n)
		}
	}
}

func init() {
	codecapi.Register(ast.BasicLit{}, ast_BasicLit_codec{})
	codecapi.Register(&ast.BasicLit{}, ptr_ast_BasicLit_codec{})
}

// Fields of ast_BinaryExpr: X OpPos Op Y

type ptr_ast_BinaryExpr_codec struct{}

func (ptr_ast_BinaryExpr_codec) Init() {}

func (c ptr_ast_BinaryExpr_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.BinaryExpr))
}

func (c ptr_ast_BinaryExpr_codec) encode(e *codecapi.Encoder, x *ast.BinaryExpr) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_BinaryExpr_codec{}).encode(e, x)
}

func (c ptr_ast_BinaryExpr_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.BinaryExpr
	c.decode(d, &x)
	return x
}

func (c ptr_ast_BinaryExpr_codec) decode(d *codecapi.Decoder, p **ast.BinaryExpr) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.BinaryExpr)
		return
	}
	var x ast.BinaryExpr
	d.StoreRef(&x)
	(ast_BinaryExpr_codec{}).decode(d, &x)
	*p = &x
}

type ast_BinaryExpr_codec struct{}

func (ast_BinaryExpr_codec) Init() {}

func (c ast_BinaryExpr_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.BinaryExpr)
	c.encode(e, &s)
}

func (c ast_BinaryExpr_codec) encode(e *codecapi.Encoder, x *ast.BinaryExpr) {
	e.StartStruct()
	if x.X != nil {
		e.EncodeUint(0)
		e.EncodeAny(x.X)
	}
	if x.OpPos != 0 {
		e.EncodeUint(1)
		e.EncodeInt(int64(x.OpPos))
	}
	if x.Op != 0 {
		e.EncodeUint(2)
		e.EncodeInt(int64(x.Op))
	}
	if x.Y != nil {
		e.EncodeUint(3)
		e.EncodeAny(x.Y)
	}
	e.EndStruct()
}

func (c ast_BinaryExpr_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.BinaryExpr
	c.decode(d, &x)
	return x
}

func (c ast_BinaryExpr_codec) decode(d *codecapi.Decoder, x *ast.BinaryExpr) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.X = d.DecodeAny().(ast.Expr)
		case 1:
			x.OpPos = token.Pos(d.DecodeInt())
		case 2:
			x.Op = token.Token(d.DecodeInt())
		case 3:
			x.Y = d.DecodeAny().(ast.Expr)
		default:
			d.UnknownField("ast.BinaryExpr", n)
		}
	}
}

func init() {
	codecapi.Register(ast.BinaryExpr{}, ast_BinaryExpr_codec{})
	codecapi.Register(&ast.BinaryExpr{}, ptr_ast_BinaryExpr_codec{})
}

// Fields of ast_BlockStmt: Lbrace List Rbrace

type ptr_ast_BlockStmt_codec struct{}

func (ptr_ast_BlockStmt_codec) Init() {}

func (c ptr_ast_BlockStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.BlockStmt))
}

func (c ptr_ast_BlockStmt_codec) encode(e *codecapi.Encoder, x *ast.BlockStmt) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_BlockStmt_codec{}).encode(e, x)
}

func (c ptr_ast_BlockStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.BlockStmt
	c.decode(d, &x)
	return x
}

func (c ptr_ast_BlockStmt_codec) decode(d *codecapi.Decoder, p **ast.BlockStmt) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.BlockStmt)
		return
	}
	var x ast.BlockStmt
	d.StoreRef(&x)
	(ast_BlockStmt_codec{}).decode(d, &x)
	*p = &x
}

type ast_BlockStmt_codec struct{}

func (ast_BlockStmt_codec) Init() {}

func (c ast_BlockStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.BlockStmt)
	c.encode(e, &s)
}

func (c ast_BlockStmt_codec) encode(e *codecapi.Encoder, x *ast.BlockStmt) {
	e.StartStruct()
	if x.Lbrace != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.Lbrace))
	}
	if x.List != nil {
		e.EncodeUint(1)
		(slice_ast_Stmt_codec{}).encode(e, x.List)
	}
	if x.Rbrace != 0 {
		e.EncodeUint(2)
		e.EncodeInt(int64(x.Rbrace))
	}
	e.EndStruct()
}

func (c ast_BlockStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.BlockStmt
	c.decode(d, &x)
	return x
}

func (c ast_BlockStmt_codec) decode(d *codecapi.Decoder, x *ast.BlockStmt) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Lbrace = token.Pos(d.DecodeInt())
		case 1:
			(slice_ast_Stmt_codec{}).decode(d, &x.List)
		case 2:
			x.Rbrace = token.Pos(d.DecodeInt())
		default:
			d.UnknownField("ast.BlockStmt", n)
		}
	}
}

func init() {
	codecapi.Register(ast.BlockStmt{}, ast_BlockStmt_codec{})
	codecapi.Register(&ast.BlockStmt{}, ptr_ast_BlockStmt_codec{})
}

// Fields of ast_BranchStmt: TokPos Tok Label

type ptr_ast_BranchStmt_codec struct{}

func (ptr_ast_BranchStmt_codec) Init() {}

func (c ptr_ast_BranchStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.BranchStmt))
}

func (c ptr_ast_BranchStmt_codec) encode(e *codecapi.Encoder, x *ast.BranchStmt) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_BranchStmt_codec{}).encode(e, x)
}

func (c ptr_ast_BranchStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.BranchStmt
	c.decode(d, &x)
	return x
}

func (c ptr_ast_BranchStmt_codec) decode(d *codecapi.Decoder, p **ast.BranchStmt) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.BranchStmt)
		return
	}
	var x ast.BranchStmt
	d.StoreRef(&x)
	(ast_BranchStmt_codec{}).decode(d, &x)
	*p = &x
}

type ast_BranchStmt_codec struct{}

func (ast_BranchStmt_codec) Init() {}

func (c ast_BranchStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.BranchStmt)
	c.encode(e, &s)
}

func (c ast_BranchStmt_codec) encode(e *codecapi.Encoder, x *ast.BranchStmt) {
	e.StartStruct()
	if x.TokPos != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.TokPos))
	}
	if x.Tok != 0 {
		e.EncodeUint(1)
		e.EncodeInt(int64(x.Tok))
	}
	if x.Label != nil {
		e.EncodeUint(2)
		(ptr_ast_Ident_codec{}).encode(e, x.Label)
	}
	e.EndStruct()
}

func (c ast_BranchStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.BranchStmt
	c.decode(d, &x)
	return x
}

func (c ast_BranchStmt_codec) decode(d *codecapi.Decoder, x *ast.BranchStmt) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.TokPos = token.Pos(d.DecodeInt())
		case 1:
			x.Tok = token.Token(d.DecodeInt())
		case 2:
			(ptr_ast_Ident_codec{}).decode(d, &x.Label)
		default:
			d.UnknownField("ast.BranchStmt", n)
		}
	}
}

func init() {
	codecapi.Register(ast.BranchStmt{}, ast_BranchStmt_codec{})
	codecapi.Register(&ast.BranchStmt{}, ptr_ast_BranchStmt_codec{})
}

// Fields of ast_CallExpr: Fun Lparen Args Ellipsis Rparen

type ptr_ast_CallExpr_codec struct{}

func (ptr_ast_CallExpr_codec) Init() {}

func (c ptr_ast_CallExpr_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.CallExpr))
}

func (c ptr_ast_CallExpr_codec) encode(e *codecapi.Encoder, x *ast.CallExpr) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_CallExpr_codec{}).encode(e, x)
}

func (c ptr_ast_CallExpr_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.CallExpr
	c.decode(d, &x)
	return x
}

func (c ptr_ast_CallExpr_codec) decode(d *codecapi.Decoder, p **ast.CallExpr) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.CallExpr)
		return
	}
	var x ast.CallExpr
	d.StoreRef(&x)
	(ast_CallExpr_codec{}).decode(d, &x)
	*p = &x
}

type ast_CallExpr_codec struct{}

func (ast_CallExpr_codec) Init() {}

func (c ast_CallExpr_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.CallExpr)
	c.encode(e, &s)
}

func (c ast_CallExpr_codec) encode(e *codecapi.Encoder, x *ast.CallExpr) {
	e.StartStruct()
	if x.Fun != nil {
		e.EncodeUint(0)
		e.EncodeAny(x.Fun)
	}
	if x.Lparen != 0 {
		e.EncodeUint(1)
		e.EncodeInt(int64(x.Lparen))
	}
	if x.Args != nil {
		e.EncodeUint(2)
		(slice_ast_Expr_codec{}).encode(e, x.Args)
	}
	if x.Ellipsis != 0 {
		e.EncodeUint(3)
		e.EncodeInt(int64(x.Ellipsis))
	}
	if x.Rparen != 0 {
		e.EncodeUint(4)
		e.EncodeInt(int64(x.Rparen))
	}
	e.EndStruct()
}

func (c ast_CallExpr_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.CallExpr
	c.decode(d, &x)
	return x
}

func (c ast_CallExpr_codec) decode(d *codecapi.Decoder, x *ast.CallExpr) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Fun = d.DecodeAny().(ast.Expr)
		case 1:
			x.Lparen = token.Pos(d.DecodeInt())
		case 2:
			(slice_ast_Expr_codec{}).decode(d, &x.Args)
		case 3:
			x.Ellipsis = token.Pos(d.DecodeInt())
		case 4:
			x.Rparen = token.Pos(d.DecodeInt())
		default:
			d.UnknownField("ast.CallExpr", n)
		}
	}
}

func init() {
	codecapi.Register(ast.CallExpr{}, ast_CallExpr_codec{})
	codecapi.Register(&ast.CallExpr{}, ptr_ast_CallExpr_codec{})
}

// Fields of ast_CaseClause: Case List Colon Body

type ptr_ast_CaseClause_codec struct{}

func (ptr_ast_CaseClause_codec) Init() {}

func (c ptr_ast_CaseClause_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.CaseClause))
}

func (c ptr_ast_CaseClause_codec) encode(e *codecapi.Encoder, x *ast.CaseClause) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_CaseClause_codec{}).encode(e, x)
}

func (c ptr_ast_CaseClause_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.CaseClause
	c.decode(d, &x)
	return x
}

func (c ptr_ast_CaseClause_codec) decode(d *codecapi.Decoder, p **ast.CaseClause) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.CaseClause)
		return
	}
	var x ast.CaseClause
	d.StoreRef(&x)
	(ast_CaseClause_codec{}).decode(d, &x)
	*p = &x
}

type ast_CaseClause_codec struct{}

func (ast_CaseClause_codec) Init() {}

func (c ast_CaseClause_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.CaseClause)
	c.encode(e, &s)
}

func (c ast_CaseClause_codec) encode(e *codecapi.Encoder, x *ast.CaseClause) {
	e.StartStruct()
	if x.Case != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.Case))
	}
	if x.List != nil {
		e.EncodeUint(1)
		(slice_ast_Expr_codec{}).encode(e, x.List)
	}
	if x.Colon != 0 {
		e.EncodeUint(2)
		e.EncodeInt(int64(x.Colon))
	}
	if x.Body != nil {
		e.EncodeUint(3)
		(slice_ast_Stmt_codec{}).encode(e, x.Body)
	}
	e.EndStruct()
}

func (c ast_CaseClause_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.CaseClause
	c.decode(d, &x)
	return x
}

func (c ast_CaseClause_codec) decode(d *codecapi.Decoder, x *ast.CaseClause) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Case = token.Pos(d.DecodeInt())
		case 1:
			(slice_ast_Expr_codec{}).decode(d, &x.List)
		case 2:
			x.Colon = token.Pos(d.DecodeInt())
		case 3:
			(slice_ast_Stmt_codec{}).decode(d, &x.Body)
		default:
			d.UnknownField("ast.CaseClause", n)
		}
	}
}

func init() {
	codecapi.Register(ast.CaseClause{}, ast_CaseClause_codec{})
	codecapi.Register(&ast.CaseClause{}, ptr_ast_CaseClause_codec{})
}

// Fields of ast_ChanType: Begin Arrow Dir Value

type ptr_ast_ChanType_codec struct{}

func (ptr_ast_ChanType_codec) Init() {}

func (c ptr_ast_ChanType_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.ChanType))
}

func (c ptr_ast_ChanType_codec) encode(e *codecapi.Encoder, x *ast.ChanType) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_ChanType_codec{}).encode(e, x)
}

func (c ptr_ast_ChanType_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.ChanType
	c.decode(d, &x)
	return x
}

func (c ptr_ast_ChanType_codec) decode(d *codecapi.Decoder, p **ast.ChanType) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.ChanType)
		return
	}
	var x ast.ChanType
	d.StoreRef(&x)
	(ast_ChanType_codec{}).decode(d, &x)
	*p = &x
}

type ast_ChanType_codec struct{}

func (ast_ChanType_codec) Init() {}

func (c ast_ChanType_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.ChanType)
	c.encode(e, &s)
}

func (c ast_ChanType_codec) encode(e *codecapi.Encoder, x *ast.ChanType) {
	e.StartStruct()
	if x.Begin != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.Begin))
	}
	if x.Arrow != 0 {
		e.EncodeUint(1)
		e.EncodeInt(int64(x.Arrow))
	}
	if x.Dir != 0 {
		e.EncodeUint(2)
		e.EncodeInt(int64(x.Dir))
	}
	if x.Value != nil {
		e.EncodeUint(3)
		e.EncodeAny(x.Value)
	}
	e.EndStruct()
}

func (c ast_ChanType_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.ChanType
	c.decode(d, &x)
	return x
}

func (c ast_ChanType_codec) decode(d *codecapi.Decoder, x *ast.ChanType) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Begin = token.Pos(d.DecodeInt())
		case 1:
			x.Arrow = token.Pos(d.DecodeInt())
		case 2:
			x.Dir = ast.ChanDir(d.DecodeInt())
		case 3:
			x.Value = d.DecodeAny().(ast.Expr)
		default:
			d.UnknownField("ast.ChanType", n)
		}
	}
}

func init() {
	codecapi.Register(ast.ChanType{}, ast_ChanType_codec{})
	codecapi.Register(&ast.ChanType{}, ptr_ast_ChanType_codec{})
}

// Fields of ast_CommClause: Case Comm Colon Body

type ptr_ast_CommClause_codec struct{}

func (ptr_ast_CommClause_codec) Init() {}

func (c ptr_ast_CommClause_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.CommClause))
}

func (c ptr_ast_CommClause_codec) encode(e *codecapi.Encoder, x *ast.CommClause) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_CommClause_codec{}).encode(e, x)
}

func (c ptr_ast_CommClause_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.CommClause
	c.decode(d, &x)
	return x
}

func (c ptr_ast_CommClause_codec) decode(d *codecapi.Decoder, p **ast.CommClause) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.CommClause)
		return
	}
	var x ast.CommClause
	d.StoreRef(&x)
	(ast_CommClause_codec{}).decode(d, &x)
	*p = &x
}

type ast_CommClause_codec struct{}

func (ast_CommClause_codec) Init() {}

func (c ast_CommClause_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.CommClause)
	c.encode(e, &s)
}

func (c ast_CommClause_codec) encode(e *codecapi.Encoder, x *ast.CommClause) {
	e.StartStruct()
	if x.Case != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.Case))
	}
	if x.Comm != nil {
		e.EncodeUint(1)
		e.EncodeAny(x.Comm)
	}
	if x.Colon != 0 {
		e.EncodeUint(2)
		e.EncodeInt(int64(x.Colon))
	}
	if x.Body != nil {
		e.EncodeUint(3)
		(slice_ast_Stmt_codec{}).encode(e, x.Body)
	}
	e.EndStruct()
}

func (c ast_CommClause_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.CommClause
	c.decode(d, &x)
	return x
}

func (c ast_CommClause_codec) decode(d *codecapi.Decoder, x *ast.CommClause) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Case = token.Pos(d.DecodeInt())
		case 1:
			x.Comm = d.DecodeAny().(ast.Stmt)
		case 2:
			x.Colon = token.Pos(d.DecodeInt())
		case 3:
			(slice_ast_Stmt_codec{}).decode(d, &x.Body)
		default:
			d.UnknownField("ast.CommClause", n)
		}
	}
}

func init() {
	codecapi.Register(ast.CommClause{}, ast_CommClause_codec{})
	codecapi.Register(&ast.CommClause{}, ptr_ast_CommClause_codec{})
}

// Fields of ast_CommentGroup: List

type ptr_ast_CommentGroup_codec struct{}

func (ptr_ast_CommentGroup_codec) Init() {}

func (c ptr_ast_CommentGroup_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.CommentGroup))
}

func (c ptr_ast_CommentGroup_codec) encode(e *codecapi.Encoder, x *ast.CommentGroup) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_CommentGroup_codec{}).encode(e, x)
}

func (c ptr_ast_CommentGroup_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.CommentGroup
	c.decode(d, &x)
	return x
}

func (c ptr_ast_CommentGroup_codec) decode(d *codecapi.Decoder, p **ast.CommentGroup) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.CommentGroup)
		return
	}
	var x ast.CommentGroup
	d.StoreRef(&x)
	(ast_CommentGroup_codec{}).decode(d, &x)
	*p = &x
}

type ast_CommentGroup_codec struct{}

func (ast_CommentGroup_codec) Init() {}

func (c ast_CommentGroup_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.CommentGroup)
	c.encode(e, &s)
}

func (c ast_CommentGroup_codec) encode(e *codecapi.Encoder, x *ast.CommentGroup) {
	e.StartStruct()
	if x.List != nil {
		e.EncodeUint(0)
		(slice_ptr_ast_Comment_codec{}).encode(e, x.List)
	}
	e.EndStruct()
}

func (c ast_CommentGroup_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.CommentGroup
	c.decode(d, &x)
	return x
}

func (c ast_CommentGroup_codec) decode(d *codecapi.Decoder, x *ast.CommentGroup) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			(slice_ptr_ast_Comment_codec{}).decode(d, &x.List)
		default:
			d.UnknownField("ast.CommentGroup", n)
		}
	}
}

func init() {
	codecapi.Register(ast.CommentGroup{}, ast_CommentGroup_codec{})
	codecapi.Register(&ast.CommentGroup{}, ptr_ast_CommentGroup_codec{})
}

// Fields of ast_Comment: Slash Text

type ptr_ast_Comment_codec struct{}

func (ptr_ast_Comment_codec) Init() {}

func (c ptr_ast_Comment_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.Comment))
}

func (c ptr_ast_Comment_codec) encode(e *codecapi.Encoder, x *ast.Comment) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_Comment_codec{}).encode(e, x)
}

func (c ptr_ast_Comment_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.Comment
	c.decode(d, &x)
	return x
}

func (c ptr_ast_Comment_codec) decode(d *codecapi.Decoder, p **ast.Comment) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.Comment)
		return
	}
	var x ast.Comment
	d.StoreRef(&x)
	(ast_Comment_codec{}).decode(d, &x)
	*p = &x
}

type ast_Comment_codec struct{}

func (ast_Comment_codec) Init() {}

func (c ast_Comment_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.Comment)
	c.encode(e, &s)
}

func (c ast_Comment_codec) encode(e *codecapi.Encoder, x *ast.Comment) {
	e.StartStruct()
	if x.Slash != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.Slash))
	}
	if x.Text != "" {
		e.EncodeUint(1)
		e.EncodeString(x.Text)
	}
	e.EndStruct()
}

func (c ast_Comment_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.Comment
	c.decode(d, &x)
	return x
}

func (c ast_Comment_codec) decode(d *codecapi.Decoder, x *ast.Comment) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Slash = token.Pos(d.DecodeInt())
		case 1:
			x.Text = d.DecodeString()
		default:
			d.UnknownField("ast.Comment", n)
		}
	}
}

func init() {
	codecapi.Register(ast.Comment{}, ast_Comment_codec{})
	codecapi.Register(&ast.Comment{}, ptr_ast_Comment_codec{})
}

// Fields of ast_CompositeLit: Type Lbrace Elts Rbrace Incomplete

type ptr_ast_CompositeLit_codec struct{}

func (ptr_ast_CompositeLit_codec) Init() {}

func (c ptr_ast_CompositeLit_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.CompositeLit))
}

func (c ptr_ast_CompositeLit_codec) encode(e *codecapi.Encoder, x *ast.CompositeLit) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_CompositeLit_codec{}).encode(e, x)
}

func (c ptr_ast_CompositeLit_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.CompositeLit
	c.decode(d, &x)
	return x
}

func (c ptr_ast_CompositeLit_codec) decode(d *codecapi.Decoder, p **ast.CompositeLit) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.CompositeLit)
		return
	}
	var x ast.CompositeLit
	d.StoreRef(&x)
	(ast_CompositeLit_codec{}).decode(d, &x)
	*p = &x
}

type ast_CompositeLit_codec struct{}

func (ast_CompositeLit_codec) Init() {}

func (c ast_CompositeLit_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.CompositeLit)
	c.encode(e, &s)
}

func (c ast_CompositeLit_codec) encode(e *codecapi.Encoder, x *ast.CompositeLit) {
	e.StartStruct()
	if x.Type != nil {
		e.EncodeUint(0)
		e.EncodeAny(x.Type)
	}
	if x.Lbrace != 0 {
		e.EncodeUint(1)
		e.EncodeInt(int64(x.Lbrace))
	}
	if x.Elts != nil {
		e.EncodeUint(2)
		(slice_ast_Expr_codec{}).encode(e, x.Elts)
	}
	if x.Rbrace != 0 {
		e.EncodeUint(3)
		e.EncodeInt(int64(x.Rbrace))
	}
	if x.Incomplete != false {
		e.EncodeUint(4)
		e.EncodeBool(x.Incomplete)
	}
	e.EndStruct()
}

func (c ast_CompositeLit_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.CompositeLit
	c.decode(d, &x)
	return x
}

func (c ast_CompositeLit_codec) decode(d *codecapi.Decoder, x *ast.CompositeLit) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Type = d.DecodeAny().(ast.Expr)
		case 1:
			x.Lbrace = token.Pos(d.DecodeInt())
		case 2:
			(slice_ast_Expr_codec{}).decode(d, &x.Elts)
		case 3:
			x.Rbrace = token.Pos(d.DecodeInt())
		case 4:
			x.Incomplete = d.DecodeBool()
		default:
			d.UnknownField("ast.CompositeLit", n)
		}
	}
}

func init() {
	codecapi.Register(ast.CompositeLit{}, ast_CompositeLit_codec{})
	codecapi.Register(&ast.CompositeLit{}, ptr_ast_CompositeLit_codec{})
}

// Fields of ast_DeclStmt: Decl

type ptr_ast_DeclStmt_codec struct{}

func (ptr_ast_DeclStmt_codec) Init() {}

func (c ptr_ast_DeclStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.DeclStmt))
}

func (c ptr_ast_DeclStmt_codec) encode(e *codecapi.Encoder, x *ast.DeclStmt) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_DeclStmt_codec{}).encode(e, x)
}

func (c ptr_ast_DeclStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.DeclStmt
	c.decode(d, &x)
	return x
}

func (c ptr_ast_DeclStmt_codec) decode(d *codecapi.Decoder, p **ast.DeclStmt) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.DeclStmt)
		return
	}
	var x ast.DeclStmt
	d.StoreRef(&x)
	(ast_DeclStmt_codec{}).decode(d, &x)
	*p = &x
}

type ast_DeclStmt_codec struct{}

func (ast_DeclStmt_codec) Init() {}

func (c ast_DeclStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.DeclStmt)
	c.encode(e, &s)
}

func (c ast_DeclStmt_codec) encode(e *codecapi.Encoder, x *ast.DeclStmt) {
	e.StartStruct()
	if x.Decl != nil {
		e.EncodeUint(0)
		e.EncodeAny(x.Decl)
	}
	e.EndStruct()
}

func (c ast_DeclStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.DeclStmt
	c.decode(d, &x)
	return x
}

func (c ast_DeclStmt_codec) decode(d *codecapi.Decoder, x *ast.DeclStmt) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Decl = d.DecodeAny().(ast.Decl)
		default:
			d.UnknownField("ast.DeclStmt", n)
		}
	}
}

func init() {
	codecapi.Register(ast.DeclStmt{}, ast_DeclStmt_codec{})
	codecapi.Register(&ast.DeclStmt{}, ptr_ast_DeclStmt_codec{})
}

// Fields of ast_DeferStmt: Defer Call

type ptr_ast_DeferStmt_codec struct{}

func (ptr_ast_DeferStmt_codec) Init() {}

func (c ptr_ast_DeferStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.DeferStmt))
}

func (c ptr_ast_DeferStmt_codec) encode(e *codecapi.Encoder, x *ast.DeferStmt) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_DeferStmt_codec{}).encode(e, x)
}

func (c ptr_ast_DeferStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.DeferStmt
	c.decode(d, &x)
	return x
}

func (c ptr_ast_DeferStmt_codec) decode(d *codecapi.Decoder, p **ast.DeferStmt) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.DeferStmt)
		return
	}
	var x ast.DeferStmt
	d.StoreRef(&x)
	(ast_DeferStmt_codec{}).decode(d, &x)
	*p = &x
}

type ast_DeferStmt_codec struct{}

func (ast_DeferStmt_codec) Init() {}

func (c ast_DeferStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.DeferStmt)
	c.encode(e, &s)
}

func (c ast_DeferStmt_codec) encode(e *codecapi.Encoder, x *ast.DeferStmt) {
	e.StartStruct()
	if x.Defer != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.Defer))
	}
	if x.Call != nil {
		e.EncodeUint(1)
		(ptr_ast_CallExpr_codec{}).encode(e, x.Call)
	}
	e.EndStruct()
}

func (c ast_DeferStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.DeferStmt
	c.decode(d, &x)
	return x
}

func (c ast_DeferStmt_codec) decode(d *codecapi.Decoder, x *ast.DeferStmt) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Defer = token.Pos(d.DecodeInt())
		case 1:
			(ptr_ast_CallExpr_codec{}).decode(d, &x.Call)
		default:
			d.UnknownField("ast.DeferStmt", n)
		}
	}
}

func init() {
	codecapi.Register(ast.DeferStmt{}, ast_DeferStmt_codec{})
	codecapi.Register(&ast.DeferStmt{}, ptr_ast_DeferStmt_codec{})
}

// Fields of ast_Ellipsis: Ellipsis Elt

type ptr_ast_Ellipsis_codec struct{}

func (ptr_ast_Ellipsis_codec) Init() {}

func (c ptr_ast_Ellipsis_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.Ellipsis))
}

func (c ptr_ast_Ellipsis_codec) encode(e *codecapi.Encoder, x *ast.Ellipsis) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_Ellipsis_codec{}).encode(e, x)
}

func (c ptr_ast_Ellipsis_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.Ellipsis
	c.decode(d, &x)
	return x
}

func (c ptr_ast_Ellipsis_codec) decode(d *codecapi.Decoder, p **ast.Ellipsis) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.Ellipsis)
		return
	}
	var x ast.Ellipsis
	d.StoreRef(&x)
	(ast_Ellipsis_codec{}).decode(d, &x)
	*p = &x
}

type ast_Ellipsis_codec struct{}

func (ast_Ellipsis_codec) Init() {}

func (c ast_Ellipsis_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.Ellipsis)
	c.encode(e, &s)
}

func (c ast_Ellipsis_codec) encode(e *codecapi.Encoder, x *ast.Ellipsis) {
	e.StartStruct()
	if x.Ellipsis != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.Ellipsis))
	}
	if x.Elt != nil {
		e.EncodeUint(1)
		e.EncodeAny(x.Elt)
	}
	e.EndStruct()
}

func (c ast_Ellipsis_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.Ellipsis
	c.decode(d, &x)
	return x
}

func (c ast_Ellipsis_codec) decode(d *codecapi.Decoder, x *ast.Ellipsis) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Ellipsis = token.Pos(d.DecodeInt())
		case 1:
			x.Elt = d.DecodeAny().(ast.Expr)
		default:
			d.UnknownField("ast.Ellipsis", n)
		}
	}
}

func init() {
	codecapi.Register(ast.Ellipsis{}, ast_Ellipsis_codec{})
	codecapi.Register(&ast.Ellipsis{}, ptr_ast_Ellipsis_codec{})
}

// Fields of ast_EmptyStmt: Semicolon Implicit

type ptr_ast_EmptyStmt_codec struct{}

func (ptr_ast_EmptyStmt_codec) Init() {}

func (c ptr_ast_EmptyStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.EmptyStmt))
}

func (c ptr_ast_EmptyStmt_codec) encode(e *codecapi.Encoder, x *ast.EmptyStmt) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_EmptyStmt_codec{}).encode(e, x)
}

func (c ptr_ast_EmptyStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.EmptyStmt
	c.decode(d, &x)
	return x
}

func (c ptr_ast_EmptyStmt_codec) decode(d *codecapi.Decoder, p **ast.EmptyStmt) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.EmptyStmt)
		return
	}
	var x ast.EmptyStmt
	d.StoreRef(&x)
	(ast_EmptyStmt_codec{}).decode(d, &x)
	*p = &x
}

type ast_EmptyStmt_codec struct{}

func (ast_EmptyStmt_codec) Init() {}

func (c ast_EmptyStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.EmptyStmt)
	c.encode(e, &s)
}

func (c ast_EmptyStmt_codec) encode(e *codecapi.Encoder, x *ast.EmptyStmt) {
	e.StartStruct()
	if x.Semicolon != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.Semicolon))
	}
	if x.Implicit != false {
		e.EncodeUint(1)
		e.EncodeBool(x.Implicit)
	}
	e.EndStruct()
}

func (c ast_EmptyStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.EmptyStmt
	c.decode(d, &x)
	return x
}

func (c ast_EmptyStmt_codec) decode(d *codecapi.Decoder, x *ast.EmptyStmt) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Semicolon = token.Pos(d.DecodeInt())
		case 1:
			x.Implicit = d.DecodeBool()
		default:
			d.UnknownField("ast.EmptyStmt", n)
		}
	}
}

func init() {
	codecapi.Register(ast.EmptyStmt{}, ast_EmptyStmt_codec{})
	codecapi.Register(&ast.EmptyStmt{}, ptr_ast_EmptyStmt_codec{})
}

// Fields of ast_ExprStmt: X

type ptr_ast_ExprStmt_codec struct{}

func (ptr_ast_ExprStmt_codec) Init() {}

func (c ptr_ast_ExprStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.ExprStmt))
}

func (c ptr_ast_ExprStmt_codec) encode(e *codecapi.Encoder, x *ast.ExprStmt) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_ExprStmt_codec{}).encode(e, x)
}

func (c ptr_ast_ExprStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.ExprStmt
	c.decode(d, &x)
	return x
}

func (c ptr_ast_ExprStmt_codec) decode(d *codecapi.Decoder, p **ast.ExprStmt) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.ExprStmt)
		return
	}
	var x ast.ExprStmt
	d.StoreRef(&x)
	(ast_ExprStmt_codec{}).decode(d, &x)
	*p = &x
}

type ast_ExprStmt_codec struct{}

func (ast_ExprStmt_codec) Init() {}

func (c ast_ExprStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.ExprStmt)
	c.encode(e, &s)
}

func (c ast_ExprStmt_codec) encode(e *codecapi.Encoder, x *ast.ExprStmt) {
	e.StartStruct()
	if x.X != nil {
		e.EncodeUint(0)
		e.EncodeAny(x.X)
	}
	e.EndStruct()
}

func (c ast_ExprStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.ExprStmt
	c.decode(d, &x)
	return x
}

func (c ast_ExprStmt_codec) decode(d *codecapi.Decoder, x *ast.ExprStmt) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.X = d.DecodeAny().(ast.Expr)
		default:
			d.UnknownField("ast.ExprStmt", n)
		}
	}
}

func init() {
	codecapi.Register(ast.ExprStmt{}, ast_ExprStmt_codec{})
	codecapi.Register(&ast.ExprStmt{}, ptr_ast_ExprStmt_codec{})
}

// Fields of ast_FieldList: Opening List Closing

type ptr_ast_FieldList_codec struct{}

func (ptr_ast_FieldList_codec) Init() {}

func (c ptr_ast_FieldList_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.FieldList))
}

func (c ptr_ast_FieldList_codec) encode(e *codecapi.Encoder, x *ast.FieldList) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_FieldList_codec{}).encode(e, x)
}

func (c ptr_ast_FieldList_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.FieldList
	c.decode(d, &x)
	return x
}

func (c ptr_ast_FieldList_codec) decode(d *codecapi.Decoder, p **ast.FieldList) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.FieldList)
		return
	}
	var x ast.FieldList
	d.StoreRef(&x)
	(ast_FieldList_codec{}).decode(d, &x)
	*p = &x
}

type ast_FieldList_codec struct{}

func (ast_FieldList_codec) Init() {}

func (c ast_FieldList_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.FieldList)
	c.encode(e, &s)
}

func (c ast_FieldList_codec) encode(e *codecapi.Encoder, x *ast.FieldList) {
	e.StartStruct()
	if x.Opening != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.Opening))
	}
	if x.List != nil {
		e.EncodeUint(1)
		(slice_ptr_ast_Field_codec{}).encode(e, x.List)
	}
	if x.Closing != 0 {
		e.EncodeUint(2)
		e.EncodeInt(int64(x.Closing))
	}
	e.EndStruct()
}

func (c ast_FieldList_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.FieldList
	c.decode(d, &x)
	return x
}

func (c ast_FieldList_codec) decode(d *codecapi.Decoder, x *ast.FieldList) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Opening = token.Pos(d.DecodeInt())
		case 1:
			(slice_ptr_ast_Field_codec{}).decode(d, &x.List)
		case 2:
			x.Closing = token.Pos(d.DecodeInt())
		default:
			d.UnknownField("ast.FieldList", n)
		}
	}
}

func init() {
	codecapi.Register(ast.FieldList{}, ast_FieldList_codec{})
	codecapi.Register(&ast.FieldList{}, ptr_ast_FieldList_codec{})
}

// Fields of ast_Field: Doc Names Type Tag Comment

type ptr_ast_Field_codec struct{}

func (ptr_ast_Field_codec) Init() {}

func (c ptr_ast_Field_codec) Encode(e *codecapi.Encoder, x interface{}) { c.encode(e, x.(*ast.Field)) }

func (c ptr_ast_Field_codec) encode(e *codecapi.Encoder, x *ast.Field) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_Field_codec{}).encode(e, x)
}

func (c ptr_ast_Field_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.Field
	c.decode(d, &x)
	return x
}

func (c ptr_ast_Field_codec) decode(d *codecapi.Decoder, p **ast.Field) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.Field)
		return
	}
	var x ast.Field
	d.StoreRef(&x)
	(ast_Field_codec{}).decode(d, &x)
	*p = &x
}

type ast_Field_codec struct{}

func (ast_Field_codec) Init() {}

func (c ast_Field_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.Field)
	c.encode(e, &s)
}

func (c ast_Field_codec) encode(e *codecapi.Encoder, x *ast.Field) {
	e.StartStruct()
	if x.Doc != nil {
		e.EncodeUint(0)
		(ptr_ast_CommentGroup_codec{}).encode(e, x.Doc)
	}
	if x.Names != nil {
		e.EncodeUint(1)
		(slice_ptr_ast_Ident_codec{}).encode(e, x.Names)
	}
	if x.Type != nil {
		e.EncodeUint(2)
		e.EncodeAny(x.Type)
	}
	if x.Tag != nil {
		e.EncodeUint(3)
		(ptr_ast_BasicLit_codec{}).encode(e, x.Tag)
	}
	if x.Comment != nil {
		e.EncodeUint(4)
		(ptr_ast_CommentGroup_codec{}).encode(e, x.Comment)
	}
	e.EndStruct()
}

func (c ast_Field_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.Field
	c.decode(d, &x)
	return x
}

func (c ast_Field_codec) decode(d *codecapi.Decoder, x *ast.Field) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			(ptr_ast_CommentGroup_codec{}).decode(d, &x.Doc)
		case 1:
			(slice_ptr_ast_Ident_codec{}).decode(d, &x.Names)
		case 2:
			x.Type = d.DecodeAny().(ast.Expr)
		case 3:
			(ptr_ast_BasicLit_codec{}).decode(d, &x.Tag)
		case 4:
			(ptr_ast_CommentGroup_codec{}).decode(d, &x.Comment)
		default:
			d.UnknownField("ast.Field", n)
		}
	}
}

func init() {
	codecapi.Register(ast.Field{}, ast_Field_codec{})
	codecapi.Register(&ast.Field{}, ptr_ast_Field_codec{})
}

// Fields of ast_ForStmt: For Init Cond Post Body

type ptr_ast_ForStmt_codec struct{}

func (ptr_ast_ForStmt_codec) Init() {}

func (c ptr_ast_ForStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.ForStmt))
}

func (c ptr_ast_ForStmt_codec) encode(e *codecapi.Encoder, x *ast.ForStmt) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_ForStmt_codec{}).encode(e, x)
}

func (c ptr_ast_ForStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.ForStmt
	c.decode(d, &x)
	return x
}

func (c ptr_ast_ForStmt_codec) decode(d *codecapi.Decoder, p **ast.ForStmt) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.ForStmt)
		return
	}
	var x ast.ForStmt
	d.StoreRef(&x)
	(ast_ForStmt_codec{}).decode(d, &x)
	*p = &x
}

type ast_ForStmt_codec struct{}

func (ast_ForStmt_codec) Init() {}

func (c ast_ForStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.ForStmt)
	c.encode(e, &s)
}

func (c ast_ForStmt_codec) encode(e *codecapi.Encoder, x *ast.ForStmt) {
	e.StartStruct()
	if x.For != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.For))
	}
	if x.Init != nil {
		e.EncodeUint(1)
		e.EncodeAny(x.Init)
	}
	if x.Cond != nil {
		e.EncodeUint(2)
		e.EncodeAny(x.Cond)
	}
	if x.Post != nil {
		e.EncodeUint(3)
		e.EncodeAny(x.Post)
	}
	if x.Body != nil {
		e.EncodeUint(4)
		(ptr_ast_BlockStmt_codec{}).encode(e, x.Body)
	}
	e.EndStruct()
}

func (c ast_ForStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.ForStmt
	c.decode(d, &x)
	return x
}

func (c ast_ForStmt_codec) decode(d *codecapi.Decoder, x *ast.ForStmt) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.For = token.Pos(d.DecodeInt())
		case 1:
			x.Init = d.DecodeAny().(ast.Stmt)
		case 2:
			x.Cond = d.DecodeAny().(ast.Expr)
		case 3:
			x.Post = d.DecodeAny().(ast.Stmt)
		case 4:
			(ptr_ast_BlockStmt_codec{}).decode(d, &x.Body)
		default:
			d.UnknownField("ast.ForStmt", n)
		}
	}
}

func init() {
	codecapi.Register(ast.ForStmt{}, ast_ForStmt_codec{})
	codecapi.Register(&ast.ForStmt{}, ptr_ast_ForStmt_codec{})
}

// Fields of ast_FuncDecl: Doc Recv Name Type Body

type ptr_ast_FuncDecl_codec struct{}

func (ptr_ast_FuncDecl_codec) Init() {}

func (c ptr_ast_FuncDecl_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.FuncDecl))
}

func (c ptr_ast_FuncDecl_codec) encode(e *codecapi.Encoder, x *ast.FuncDecl) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_FuncDecl_codec{}).encode(e, x)
}

func (c ptr_ast_FuncDecl_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.FuncDecl
	c.decode(d, &x)
	return x
}

func (c ptr_ast_FuncDecl_codec) decode(d *codecapi.Decoder, p **ast.FuncDecl) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.FuncDecl)
		return
	}
	var x ast.FuncDecl
	d.StoreRef(&x)
	(ast_FuncDecl_codec{}).decode(d, &x)
	*p = &x
}

type ast_FuncDecl_codec struct{}

func (ast_FuncDecl_codec) Init() {}

func (c ast_FuncDecl_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.FuncDecl)
	c.encode(e, &s)
}

func (c ast_FuncDecl_codec) encode(e *codecapi.Encoder, x *ast.FuncDecl) {
	e.StartStruct()
	if x.Doc != nil {
		e.EncodeUint(0)
		(ptr_ast_CommentGroup_codec{}).encode(e, x.Doc)
	}
	if x.Recv != nil {
		e.EncodeUint(1)
		(ptr_ast_FieldList_codec{}).encode(e, x.Recv)
	}
	if x.Name != nil {
		e.EncodeUint(2)
		(ptr_ast_Ident_codec{}).encode(e, x.Name)
	}
	if x.Type != nil {
		e.EncodeUint(3)
		(ptr_ast_FuncType_codec{}).encode(e, x.Type)
	}
	if x.Body != nil {
		e.EncodeUint(4)
		(ptr_ast_BlockStmt_codec{}).encode(e, x.Body)
	}
	e.EndStruct()
}

func (c ast_FuncDecl_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.FuncDecl
	c.decode(d, &x)
	return x
}

func (c ast_FuncDecl_codec) decode(d *codecapi.Decoder, x *ast.FuncDecl) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			(ptr_ast_CommentGroup_codec{}).decode(d, &x.Doc)
		case 1:
			(ptr_ast_FieldList_codec{}).decode(d, &x.Recv)
		case 2:
			(ptr_ast_Ident_codec{}).decode(d, &x.Name)
		case 3:
			(ptr_ast_FuncType_codec{}).decode(d, &x.Type)
		case 4:
			(ptr_ast_BlockStmt_codec{}).decode(d, &x.Body)
		default:
			d.UnknownField("ast.FuncDecl", n)
		}
	}
}

func init() {
	codecapi.Register(ast.FuncDecl{}, ast_FuncDecl_codec{})
	codecapi.Register(&ast.FuncDecl{}, ptr_ast_FuncDecl_codec{})
}

// Fields of ast_FuncLit: Type Body

type ptr_ast_FuncLit_codec struct{}

func (ptr_ast_FuncLit_codec) Init() {}

func (c ptr_ast_FuncLit_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.FuncLit))
}

func (c ptr_ast_FuncLit_codec) encode(e *codecapi.Encoder, x *ast.FuncLit) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_FuncLit_codec{}).encode(e, x)
}

func (c ptr_ast_FuncLit_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.FuncLit
	c.decode(d, &x)
	return x
}

func (c ptr_ast_FuncLit_codec) decode(d *codecapi.Decoder, p **ast.FuncLit) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.FuncLit)
		return
	}
	var x ast.FuncLit
	d.StoreRef(&x)
	(ast_FuncLit_codec{}).decode(d, &x)
	*p = &x
}

type ast_FuncLit_codec struct{}

func (ast_FuncLit_codec) Init() {}

func (c ast_FuncLit_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.FuncLit)
	c.encode(e, &s)
}

func (c ast_FuncLit_codec) encode(e *codecapi.Encoder, x *ast.FuncLit) {
	e.StartStruct()
	if x.Type != nil {
		e.EncodeUint(0)
		(ptr_ast_FuncType_codec{}).encode(e, x.Type)
	}
	if x.Body != nil {
		e.EncodeUint(1)
		(ptr_ast_BlockStmt_codec{}).encode(e, x.Body)
	}
	e.EndStruct()
}

func (c ast_FuncLit_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.FuncLit
	c.decode(d, &x)
	return x
}

func (c ast_FuncLit_codec) decode(d *codecapi.Decoder, x *ast.FuncLit) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			(ptr_ast_FuncType_codec{}).decode(d, &x.Type)
		case 1:
			(ptr_ast_BlockStmt_codec{}).decode(d, &x.Body)
		default:
			d.UnknownField("ast.FuncLit", n)
		}
	}
}

func init() {
	codecapi.Register(ast.FuncLit{}, ast_FuncLit_codec{})
	codecapi.Register(&ast.FuncLit{}, ptr_ast_FuncLit_codec{})
}

// Fields of ast_FuncType: Func Params Results

type ptr_ast_FuncType_codec struct{}

func (ptr_ast_FuncType_codec) Init() {}

func (c ptr_ast_FuncType_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.FuncType))
}

func (c ptr_ast_FuncType_codec) encode(e *codecapi.Encoder, x *ast.FuncType) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_FuncType_codec{}).encode(e, x)
}

func (c ptr_ast_FuncType_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.FuncType
	c.decode(d, &x)
	return x
}

func (c ptr_ast_FuncType_codec) decode(d *codecapi.Decoder, p **ast.FuncType) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.FuncType)
		return
	}
	var x ast.FuncType
	d.StoreRef(&x)
	(ast_FuncType_codec{}).decode(d, &x)
	*p = &x
}

type ast_FuncType_codec struct{}

func (ast_FuncType_codec) Init() {}

func (c ast_FuncType_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.FuncType)
	c.encode(e, &s)
}

func (c ast_FuncType_codec) encode(e *codecapi.Encoder, x *ast.FuncType) {
	e.StartStruct()
	if x.Func != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.Func))
	}
	if x.Params != nil {
		e.EncodeUint(1)
		(ptr_ast_FieldList_codec{}).encode(e, x.Params)
	}
	if x.Results != nil {
		e.EncodeUint(2)
		(ptr_ast_FieldList_codec{}).encode(e, x.Results)
	}
	e.EndStruct()
}

func (c ast_FuncType_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.FuncType
	c.decode(d, &x)
	return x
}

func (c ast_FuncType_codec) decode(d *codecapi.Decoder, x *ast.FuncType) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Func = token.Pos(d.DecodeInt())
		case 1:
			(ptr_ast_FieldList_codec{}).decode(d, &x.Params)
		case 2:
			(ptr_ast_FieldList_codec{}).decode(d, &x.Results)
		default:
			d.UnknownField("ast.FuncType", n)
		}
	}
}

func init() {
	codecapi.Register(ast.FuncType{}, ast_FuncType_codec{})
	codecapi.Register(&ast.FuncType{}, ptr_ast_FuncType_codec{})
}

// Fields of ast_GenDecl: Doc TokPos Tok Lparen Specs Rparen

type ptr_ast_GenDecl_codec struct{}

func (ptr_ast_GenDecl_codec) Init() {}

func (c ptr_ast_GenDecl_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.GenDecl))
}

func (c ptr_ast_GenDecl_codec) encode(e *codecapi.Encoder, x *ast.GenDecl) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_GenDecl_codec{}).encode(e, x)
}

func (c ptr_ast_GenDecl_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.GenDecl
	c.decode(d, &x)
	return x
}

func (c ptr_ast_GenDecl_codec) decode(d *codecapi.Decoder, p **ast.GenDecl) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.GenDecl)
		return
	}
	var x ast.GenDecl
	d.StoreRef(&x)
	(ast_GenDecl_codec{}).decode(d, &x)
	*p = &x
}

type ast_GenDecl_codec struct{}

func (ast_GenDecl_codec) Init() {}

func (c ast_GenDecl_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.GenDecl)
	c.encode(e, &s)
}

func (c ast_GenDecl_codec) encode(e *codecapi.Encoder, x *ast.GenDecl) {
	e.StartStruct()
	if x.Doc != nil {
		e.EncodeUint(0)
		(ptr_ast_CommentGroup_codec{}).encode(e, x.Doc)
	}
	if x.TokPos != 0 {
		e.EncodeUint(1)
		e.EncodeInt(int64(x.TokPos))
	}
	if x.Tok != 0 {
		e.EncodeUint(2)
		e.EncodeInt(int64(x.Tok))
	}
	if x.Lparen != 0 {
		e.EncodeUint(3)
		e.EncodeInt(int64(x.Lparen))
	}
	if x.Specs != nil {
		e.EncodeUint(4)
		(slice_ast_Spec_codec{}).encode(e, x.Specs)
	}
	if x.Rparen != 0 {
		e.EncodeUint(5)
		e.EncodeInt(int64(x.Rparen))
	}
	e.EndStruct()
}

func (c ast_GenDecl_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.GenDecl
	c.decode(d, &x)
	return x
}

func (c ast_GenDecl_codec) decode(d *codecapi.Decoder, x *ast.GenDecl) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			(ptr_ast_CommentGroup_codec{}).decode(d, &x.Doc)
		case 1:
			x.TokPos = token.Pos(d.DecodeInt())
		case 2:
			x.Tok = token.Token(d.DecodeInt())
		case 3:
			x.Lparen = token.Pos(d.DecodeInt())
		case 4:
			(slice_ast_Spec_codec{}).decode(d, &x.Specs)
		case 5:
			x.Rparen = token.Pos(d.DecodeInt())
		default:
			d.UnknownField("ast.GenDecl", n)
		}
	}
}

func init() {
	codecapi.Register(ast.GenDecl{}, ast_GenDecl_codec{})
	codecapi.Register(&ast.GenDecl{}, ptr_ast_GenDecl_codec{})
}

// Fields of ast_GoStmt: Go Call

type ptr_ast_GoStmt_codec struct{}

func (ptr_ast_GoStmt_codec) Init() {}

func (c ptr_ast_GoStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.GoStmt))
}

func (c ptr_ast_GoStmt_codec) encode(e *codecapi.Encoder, x *ast.GoStmt) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_GoStmt_codec{}).encode(e, x)
}

func (c ptr_ast_GoStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.GoStmt
	c.decode(d, &x)
	return x
}

func (c ptr_ast_GoStmt_codec) decode(d *codecapi.Decoder, p **ast.GoStmt) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.GoStmt)
		return
	}
	var x ast.GoStmt
	d.StoreRef(&x)
	(ast_GoStmt_codec{}).decode(d, &x)
	*p = &x
}

type ast_GoStmt_codec struct{}

func (ast_GoStmt_codec) Init() {}

func (c ast_GoStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.GoStmt)
	c.encode(e, &s)
}

func (c ast_GoStmt_codec) encode(e *codecapi.Encoder, x *ast.GoStmt) {
	e.StartStruct()
	if x.Go != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.Go))
	}
	if x.Call != nil {
		e.EncodeUint(1)
		(ptr_ast_CallExpr_codec{}).encode(e, x.Call)
	}
	e.EndStruct()
}

func (c ast_GoStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.GoStmt
	c.decode(d, &x)
	return x
}

func (c ast_GoStmt_codec) decode(d *codecapi.Decoder, x *ast.GoStmt) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Go = token.Pos(d.DecodeInt())
		case 1:
			(ptr_ast_CallExpr_codec{}).decode(d, &x.Call)
		default:
			d.UnknownField("ast.GoStmt", n)
		}
	}
}

func init() {
	codecapi.Register(ast.GoStmt{}, ast_GoStmt_codec{})
	codecapi.Register(&ast.GoStmt{}, ptr_ast_GoStmt_codec{})
}

// Fields of ast_Ident: NamePos Name Obj

type ptr_ast_Ident_codec struct{}

func (ptr_ast_Ident_codec) Init() {}

func (c ptr_ast_Ident_codec) Encode(e *codecapi.Encoder, x interface{}) { c.encode(e, x.(*ast.Ident)) }

func (c ptr_ast_Ident_codec) encode(e *codecapi.Encoder, x *ast.Ident) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_Ident_codec{}).encode(e, x)
}

func (c ptr_ast_Ident_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.Ident
	c.decode(d, &x)
	return x
}

func (c ptr_ast_Ident_codec) decode(d *codecapi.Decoder, p **ast.Ident) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.Ident)
		return
	}
	var x ast.Ident
	d.StoreRef(&x)
	(ast_Ident_codec{}).decode(d, &x)
	*p = &x
}

type ast_Ident_codec struct{}

func (ast_Ident_codec) Init() {}

func (c ast_Ident_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.Ident)
	c.encode(e, &s)
}

func (c ast_Ident_codec) encode(e *codecapi.Encoder, x *ast.Ident) {
	e.StartStruct()
	if x.NamePos != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.NamePos))
	}
	if x.Name != "" {
		e.EncodeUint(1)
		e.EncodeString(x.Name)
	}
	if x.Obj != nil {
		e.EncodeUint(2)
		(ptr_ast_Object_codec{}).encode(e, x.Obj)
	}
	e.EndStruct()
}

func (c ast_Ident_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.Ident
	c.decode(d, &x)
	return x
}

func (c ast_Ident_codec) decode(d *codecapi.Decoder, x *ast.Ident) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.NamePos = token.Pos(d.DecodeInt())
		case 1:
			x.Name = d.DecodeString()
		case 2:
			(ptr_ast_Object_codec{}).decode(d, &x.Obj)
		default:
			d.UnknownField("ast.Ident", n)
		}
	}
}

func init() {
	codecapi.Register(ast.Ident{}, ast_Ident_codec{})
	codecapi.Register(&ast.Ident{}, ptr_ast_Ident_codec{})
}

// Fields of ast_IfStmt: If Init Cond Body Else

type ptr_ast_IfStmt_codec struct{}

func (ptr_ast_IfStmt_codec) Init() {}

func (c ptr_ast_IfStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.IfStmt))
}

func (c ptr_ast_IfStmt_codec) encode(e *codecapi.Encoder, x *ast.IfStmt) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_IfStmt_codec{}).encode(e, x)
}

func (c ptr_ast_IfStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.IfStmt
	c.decode(d, &x)
	return x
}

func (c ptr_ast_IfStmt_codec) decode(d *codecapi.Decoder, p **ast.IfStmt) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.IfStmt)
		return
	}
	var x ast.IfStmt
	d.StoreRef(&x)
	(ast_IfStmt_codec{}).decode(d, &x)
	*p = &x
}

type ast_IfStmt_codec struct{}

func (ast_IfStmt_codec) Init() {}

func (c ast_IfStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.IfStmt)
	c.encode(e, &s)
}

func (c ast_IfStmt_codec) encode(e *codecapi.Encoder, x *ast.IfStmt) {
	e.StartStruct()
	if x.If != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.If))
	}
	if x.Init != nil {
		e.EncodeUint(1)
		e.EncodeAny(x.Init)
	}
	if x.Cond != nil {
		e.EncodeUint(2)
		e.EncodeAny(x.Cond)
	}
	if x.Body != nil {
		e.EncodeUint(3)
		(ptr_ast_BlockStmt_codec{}).encode(e, x.Body)
	}
	if x.Else != nil {
		e.EncodeUint(4)
		e.EncodeAny(x.Else)
	}
	e.EndStruct()
}

func (c ast_IfStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.IfStmt
	c.decode(d, &x)
	return x
}

func (c ast_IfStmt_codec) decode(d *codecapi.Decoder, x *ast.IfStmt) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.If = token.Pos(d.DecodeInt())
		case 1:
			x.Init = d.DecodeAny().(ast.Stmt)
		case 2:
			x.Cond = d.DecodeAny().(ast.Expr)
		case 3:
			(ptr_ast_BlockStmt_codec{}).decode(d, &x.Body)
		case 4:
			x.Else = d.DecodeAny().(ast.Stmt)
		default:
			d.UnknownField("ast.IfStmt", n)
		}
	}
}

func init() {
	codecapi.Register(ast.IfStmt{}, ast_IfStmt_codec{})
	codecapi.Register(&ast.IfStmt{}, ptr_ast_IfStmt_codec{})
}

// Fields of ast_ImportSpec: Doc Name Path Comment EndPos

type ptr_ast_ImportSpec_codec struct{}

func (ptr_ast_ImportSpec_codec) Init() {}

func (c ptr_ast_ImportSpec_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.ImportSpec))
}

func (c ptr_ast_ImportSpec_codec) encode(e *codecapi.Encoder, x *ast.ImportSpec) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_ImportSpec_codec{}).encode(e, x)
}

func (c ptr_ast_ImportSpec_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.ImportSpec
	c.decode(d, &x)
	return x
}

func (c ptr_ast_ImportSpec_codec) decode(d *codecapi.Decoder, p **ast.ImportSpec) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.ImportSpec)
		return
	}
	var x ast.ImportSpec
	d.StoreRef(&x)
	(ast_ImportSpec_codec{}).decode(d, &x)
	*p = &x
}

type ast_ImportSpec_codec struct{}

func (ast_ImportSpec_codec) Init() {}

func (c ast_ImportSpec_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.ImportSpec)
	c.encode(e, &s)
}

func (c ast_ImportSpec_codec) encode(e *codecapi.Encoder, x *ast.ImportSpec) {
	e.StartStruct()
	if x.Doc != nil {
		e.EncodeUint(0)
		(ptr_ast_CommentGroup_codec{}).encode(e, x.Doc)
	}
	if x.Name != nil {
		e.EncodeUint(1)
		(ptr_ast_Ident_codec{}).encode(e, x.Name)
	}
	if x.Path != nil {
		e.EncodeUint(2)
		(ptr_ast_BasicLit_codec{}).encode(e, x.Path)
	}
	if x.Comment != nil {
		e.EncodeUint(3)
		(ptr_ast_CommentGroup_codec{}).encode(e, x.Comment)
	}
	if x.EndPos != 0 {
		e.EncodeUint(4)
		e.EncodeInt(int64(x.EndPos))
	}
	e.EndStruct()
}

func (c ast_ImportSpec_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.ImportSpec
	c.decode(d, &x)
	return x
}

func (c ast_ImportSpec_codec) decode(d *codecapi.Decoder, x *ast.ImportSpec) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			(ptr_ast_CommentGroup_codec{}).decode(d, &x.Doc)
		case 1:
			(ptr_ast_Ident_codec{}).decode(d, &x.Name)
		case 2:
			(ptr_ast_BasicLit_codec{}).decode(d, &x.Path)
		case 3:
			(ptr_ast_CommentGroup_codec{}).decode(d, &x.Comment)
		case 4:
			x.EndPos = token.Pos(d.DecodeInt())
		default:
			d.UnknownField("ast.ImportSpec", n)
		}
	}
}

func init() {
	codecapi.Register(ast.ImportSpec{}, ast_ImportSpec_codec{})
	codecapi.Register(&ast.ImportSpec{}, ptr_ast_ImportSpec_codec{})
}

// Fields of ast_IncDecStmt: X TokPos Tok

type ptr_ast_IncDecStmt_codec struct{}

func (ptr_ast_IncDecStmt_codec) Init() {}

func (c ptr_ast_IncDecStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.IncDecStmt))
}

func (c ptr_ast_IncDecStmt_codec) encode(e *codecapi.Encoder, x *ast.IncDecStmt) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_IncDecStmt_codec{}).encode(e, x)
}

func (c ptr_ast_IncDecStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.IncDecStmt
	c.decode(d, &x)
	return x
}

func (c ptr_ast_IncDecStmt_codec) decode(d *codecapi.Decoder, p **ast.IncDecStmt) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.IncDecStmt)
		return
	}
	var x ast.IncDecStmt
	d.StoreRef(&x)
	(ast_IncDecStmt_codec{}).decode(d, &x)
	*p = &x
}

type ast_IncDecStmt_codec struct{}

func (ast_IncDecStmt_codec) Init() {}

func (c ast_IncDecStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.IncDecStmt)
	c.encode(e, &s)
}

func (c ast_IncDecStmt_codec) encode(e *codecapi.Encoder, x *ast.IncDecStmt) {
	e.StartStruct()
	if x.X != nil {
		e.EncodeUint(0)
		e.EncodeAny(x.X)
	}
	if x.TokPos != 0 {
		e.EncodeUint(1)
		e.EncodeInt(int64(x.TokPos))
	}
	if x.Tok != 0 {
		e.EncodeUint(2)
		e.EncodeInt(int64(x.Tok))
	}
	e.EndStruct()
}

func (c ast_IncDecStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.IncDecStmt
	c.decode(d, &x)
	return x
}

func (c ast_IncDecStmt_codec) decode(d *codecapi.Decoder, x *ast.IncDecStmt) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.X = d.DecodeAny().(ast.Expr)
		case 1:
			x.TokPos = token.Pos(d.DecodeInt())
		case 2:
			x.Tok = token.Token(d.DecodeInt())
		default:
			d.UnknownField("ast.IncDecStmt", n)
		}
	}
}

func init() {
	codecapi.Register(ast.IncDecStmt{}, ast_IncDecStmt_codec{})
	codecapi.Register(&ast.IncDecStmt{}, ptr_ast_IncDecStmt_codec{})
}

// Fields of ast_IndexExpr: X Lbrack Index Rbrack

type ptr_ast_IndexExpr_codec struct{}

func (ptr_ast_IndexExpr_codec) Init() {}

func (c ptr_ast_IndexExpr_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.IndexExpr))
}

func (c ptr_ast_IndexExpr_codec) encode(e *codecapi.Encoder, x *ast.IndexExpr) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_IndexExpr_codec{}).encode(e, x)
}

func (c ptr_ast_IndexExpr_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.IndexExpr
	c.decode(d, &x)
	return x
}

func (c ptr_ast_IndexExpr_codec) decode(d *codecapi.Decoder, p **ast.IndexExpr) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.IndexExpr)
		return
	}
	var x ast.IndexExpr
	d.StoreRef(&x)
	(ast_IndexExpr_codec{}).decode(d, &x)
	*p = &x
}

type ast_IndexExpr_codec struct{}

func (ast_IndexExpr_codec) Init() {}

func (c ast_IndexExpr_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.IndexExpr)
	c.encode(e, &s)
}

func (c ast_IndexExpr_codec) encode(e *codecapi.Encoder, x *ast.IndexExpr) {
	e.StartStruct()
	if x.X != nil {
		e.EncodeUint(0)
		e.EncodeAny(x.X)
	}
	if x.Lbrack != 0 {
		e.EncodeUint(1)
		e.EncodeInt(int64(x.Lbrack))
	}
	if x.Index != nil {
		e.EncodeUint(2)
		e.EncodeAny(x.Index)
	}
	if x.Rbrack != 0 {
		e.EncodeUint(3)
		e.EncodeInt(int64(x.Rbrack))
	}
	e.EndStruct()
}

func (c ast_IndexExpr_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.IndexExpr
	c.decode(d, &x)
	return x
}

func (c ast_IndexExpr_codec) decode(d *codecapi.Decoder, x *ast.IndexExpr) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.X = d.DecodeAny().(ast.Expr)
		case 1:
			x.Lbrack = token.Pos(d.DecodeInt())
		case 2:
			x.Index = d.DecodeAny().(ast.Expr)
		case 3:
			x.Rbrack = token.Pos(d.DecodeInt())
		default:
			d.UnknownField("ast.IndexExpr", n)
		}
	}
}

func init() {
	codecapi.Register(ast.IndexExpr{}, ast_IndexExpr_codec{})
	codecapi.Register(&ast.IndexExpr{}, ptr_ast_IndexExpr_codec{})
}

// Fields of ast_InterfaceType: Interface Methods Incomplete

type ptr_ast_InterfaceType_codec struct{}

func (ptr_ast_InterfaceType_codec) Init() {}

func (c ptr_ast_InterfaceType_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.InterfaceType))
}

func (c ptr_ast_InterfaceType_codec) encode(e *codecapi.Encoder, x *ast.InterfaceType) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_InterfaceType_codec{}).encode(e, x)
}

func (c ptr_ast_InterfaceType_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.InterfaceType
	c.decode(d, &x)
	return x
}

func (c ptr_ast_InterfaceType_codec) decode(d *codecapi.Decoder, p **ast.InterfaceType) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.InterfaceType)
		return
	}
	var x ast.InterfaceType
	d.StoreRef(&x)
	(ast_InterfaceType_codec{}).decode(d, &x)
	*p = &x
}

type ast_InterfaceType_codec struct{}

func (ast_InterfaceType_codec) Init() {}

func (c ast_InterfaceType_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.InterfaceType)
	c.encode(e, &s)
}

func (c ast_InterfaceType_codec) encode(e *codecapi.Encoder, x *ast.InterfaceType) {
	e.StartStruct()
	if x.Interface != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.Interface))
	}
	if x.Methods != nil {
		e.EncodeUint(1)
		(ptr_ast_FieldList_codec{}).encode(e, x.Methods)
	}
	if x.Incomplete != false {
		e.EncodeUint(2)
		e.EncodeBool(x.Incomplete)
	}
	e.EndStruct()
}

func (c ast_InterfaceType_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.InterfaceType
	c.decode(d, &x)
	return x
}

func (c ast_InterfaceType_codec) decode(d *codecapi.Decoder, x *ast.InterfaceType) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Interface = token.Pos(d.DecodeInt())
		case 1:
			(ptr_ast_FieldList_codec{}).decode(d, &x.Methods)
		case 2:
			x.Incomplete = d.DecodeBool()
		default:
			d.UnknownField("ast.InterfaceType", n)
		}
	}
}

func init() {
	codecapi.Register(ast.InterfaceType{}, ast_InterfaceType_codec{})
	codecapi.Register(&ast.InterfaceType{}, ptr_ast_InterfaceType_codec{})
}

// Fields of ast_KeyValueExpr: Key Colon Value

type ptr_ast_KeyValueExpr_codec struct{}

func (ptr_ast_KeyValueExpr_codec) Init() {}

func (c ptr_ast_KeyValueExpr_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.KeyValueExpr))
}

func (c ptr_ast_KeyValueExpr_codec) encode(e *codecapi.Encoder, x *ast.KeyValueExpr) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_KeyValueExpr_codec{}).encode(e, x)
}

func (c ptr_ast_KeyValueExpr_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.KeyValueExpr
	c.decode(d, &x)
	return x
}

func (c ptr_ast_KeyValueExpr_codec) decode(d *codecapi.Decoder, p **ast.KeyValueExpr) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.KeyValueExpr)
		return
	}
	var x ast.KeyValueExpr
	d.StoreRef(&x)
	(ast_KeyValueExpr_codec{}).decode(d, &x)
	*p = &x
}

type ast_KeyValueExpr_codec struct{}

func (ast_KeyValueExpr_codec) Init() {}

func (c ast_KeyValueExpr_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.KeyValueExpr)
	c.encode(e, &s)
}

func (c ast_KeyValueExpr_codec) encode(e *codecapi.Encoder, x *ast.KeyValueExpr) {
	e.StartStruct()
	if x.Key != nil {
		e.EncodeUint(0)
		e.EncodeAny(x.Key)
	}
	if x.Colon != 0 {
		e.EncodeUint(1)
		e.EncodeInt(int64(x.Colon))
	}
	if x.Value != nil {
		e.EncodeUint(2)
		e.EncodeAny(x.Value)
	}
	e.EndStruct()
}

func (c ast_KeyValueExpr_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.KeyValueExpr
	c.decode(d, &x)
	return x
}

func (c ast_KeyValueExpr_codec) decode(d *codecapi.Decoder, x *ast.KeyValueExpr) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Key = d.DecodeAny().(ast.Expr)
		case 1:
			x.Colon = token.Pos(d.DecodeInt())
		case 2:
			x.Value = d.DecodeAny().(ast.Expr)
		default:
			d.UnknownField("ast.KeyValueExpr", n)
		}
	}
}

func init() {
	codecapi.Register(ast.KeyValueExpr{}, ast_KeyValueExpr_codec{})
	codecapi.Register(&ast.KeyValueExpr{}, ptr_ast_KeyValueExpr_codec{})
}

// Fields of ast_LabeledStmt: Label Colon Stmt

type ptr_ast_LabeledStmt_codec struct{}

func (ptr_ast_LabeledStmt_codec) Init() {}

func (c ptr_ast_LabeledStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.LabeledStmt))
}

func (c ptr_ast_LabeledStmt_codec) encode(e *codecapi.Encoder, x *ast.LabeledStmt) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_LabeledStmt_codec{}).encode(e, x)
}

func (c ptr_ast_LabeledStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.LabeledStmt
	c.decode(d, &x)
	return x
}

func (c ptr_ast_LabeledStmt_codec) decode(d *codecapi.Decoder, p **ast.LabeledStmt) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.LabeledStmt)
		return
	}
	var x ast.LabeledStmt
	d.StoreRef(&x)
	(ast_LabeledStmt_codec{}).decode(d, &x)
	*p = &x
}

type ast_LabeledStmt_codec struct{}

func (ast_LabeledStmt_codec) Init() {}

func (c ast_LabeledStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.LabeledStmt)
	c.encode(e, &s)
}

func (c ast_LabeledStmt_codec) encode(e *codecapi.Encoder, x *ast.LabeledStmt) {
	e.StartStruct()
	if x.Label != nil {
		e.EncodeUint(0)
		(ptr_ast_Ident_codec{}).encode(e, x.Label)
	}
	if x.Colon != 0 {
		e.EncodeUint(1)
		e.EncodeInt(int64(x.Colon))
	}
	if x.Stmt != nil {
		e.EncodeUint(2)
		e.EncodeAny(x.Stmt)
	}
	e.EndStruct()
}

func (c ast_LabeledStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.LabeledStmt
	c.decode(d, &x)
	return x
}

func (c ast_LabeledStmt_codec) decode(d *codecapi.Decoder, x *ast.LabeledStmt) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			(ptr_ast_Ident_codec{}).decode(d, &x.Label)
		case 1:
			x.Colon = token.Pos(d.DecodeInt())
		case 2:
			x.Stmt = d.DecodeAny().(ast.Stmt)
		default:
			d.UnknownField("ast.LabeledStmt", n)
		}
	}
}

func init() {
	codecapi.Register(ast.LabeledStmt{}, ast_LabeledStmt_codec{})
	codecapi.Register(&ast.LabeledStmt{}, ptr_ast_LabeledStmt_codec{})
}

// Fields of ast_MapType: Map Key Value

type ptr_ast_MapType_codec struct{}

func (ptr_ast_MapType_codec) Init() {}

func (c ptr_ast_MapType_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.MapType))
}

func (c ptr_ast_MapType_codec) encode(e *codecapi.Encoder, x *ast.MapType) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_MapType_codec{}).encode(e, x)
}

func (c ptr_ast_MapType_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.MapType
	c.decode(d, &x)
	return x
}

func (c ptr_ast_MapType_codec) decode(d *codecapi.Decoder, p **ast.MapType) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.MapType)
		return
	}
	var x ast.MapType
	d.StoreRef(&x)
	(ast_MapType_codec{}).decode(d, &x)
	*p = &x
}

type ast_MapType_codec struct{}

func (ast_MapType_codec) Init() {}

func (c ast_MapType_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.MapType)
	c.encode(e, &s)
}

func (c ast_MapType_codec) encode(e *codecapi.Encoder, x *ast.MapType) {
	e.StartStruct()
	if x.Map != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.Map))
	}
	if x.Key != nil {
		e.EncodeUint(1)
		e.EncodeAny(x.Key)
	}
	if x.Value != nil {
		e.EncodeUint(2)
		e.EncodeAny(x.Value)
	}
	e.EndStruct()
}

func (c ast_MapType_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.MapType
	c.decode(d, &x)
	return x
}

func (c ast_MapType_codec) decode(d *codecapi.Decoder, x *ast.MapType) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Map = token.Pos(d.DecodeInt())
		case 1:
			x.Key = d.DecodeAny().(ast.Expr)
		case 2:
			x.Value = d.DecodeAny().(ast.Expr)
		default:
			d.UnknownField("ast.MapType", n)
		}
	}
}

func init() {
	codecapi.Register(ast.MapType{}, ast_MapType_codec{})
	codecapi.Register(&ast.MapType{}, ptr_ast_MapType_codec{})
}

// Fields of ast_ParenExpr: Lparen X Rparen

type ptr_ast_ParenExpr_codec struct{}

func (ptr_ast_ParenExpr_codec) Init() {}

func (c ptr_ast_ParenExpr_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.ParenExpr))
}

func (c ptr_ast_ParenExpr_codec) encode(e *codecapi.Encoder, x *ast.ParenExpr) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_ParenExpr_codec{}).encode(e, x)
}

func (c ptr_ast_ParenExpr_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.ParenExpr
	c.decode(d, &x)
	return x
}

func (c ptr_ast_ParenExpr_codec) decode(d *codecapi.Decoder, p **ast.ParenExpr) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.ParenExpr)
		return
	}
	var x ast.ParenExpr
	d.StoreRef(&x)
	(ast_ParenExpr_codec{}).decode(d, &x)
	*p = &x
}

type ast_ParenExpr_codec struct{}

func (ast_ParenExpr_codec) Init() {}

func (c ast_ParenExpr_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.ParenExpr)
	c.encode(e, &s)
}

func (c ast_ParenExpr_codec) encode(e *codecapi.Encoder, x *ast.ParenExpr) {
	e.StartStruct()
	if x.Lparen != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.Lparen))
	}
	if x.X != nil {
		e.EncodeUint(1)
		e.EncodeAny(x.X)
	}
	if x.Rparen != 0 {
		e.EncodeUint(2)
		e.EncodeInt(int64(x.Rparen))
	}
	e.EndStruct()
}

func (c ast_ParenExpr_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.ParenExpr
	c.decode(d, &x)
	return x
}

func (c ast_ParenExpr_codec) decode(d *codecapi.Decoder, x *ast.ParenExpr) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Lparen = token.Pos(d.DecodeInt())
		case 1:
			x.X = d.DecodeAny().(ast.Expr)
		case 2:
			x.Rparen = token.Pos(d.DecodeInt())
		default:
			d.UnknownField("ast.ParenExpr", n)
		}
	}
}

func init() {
	codecapi.Register(ast.ParenExpr{}, ast_ParenExpr_codec{})
	codecapi.Register(&ast.ParenExpr{}, ptr_ast_ParenExpr_codec{})
}

// Fields of ast_RangeStmt: For Key Value TokPos Tok X Body

type ptr_ast_RangeStmt_codec struct{}

func (ptr_ast_RangeStmt_codec) Init() {}

func (c ptr_ast_RangeStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.RangeStmt))
}

func (c ptr_ast_RangeStmt_codec) encode(e *codecapi.Encoder, x *ast.RangeStmt) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_RangeStmt_codec{}).encode(e, x)
}

func (c ptr_ast_RangeStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.RangeStmt
	c.decode(d, &x)
	return x
}

func (c ptr_ast_RangeStmt_codec) decode(d *codecapi.Decoder, p **ast.RangeStmt) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.RangeStmt)
		return
	}
	var x ast.RangeStmt
	d.StoreRef(&x)
	(ast_RangeStmt_codec{}).decode(d, &x)
	*p = &x
}

type ast_RangeStmt_codec struct{}

func (ast_RangeStmt_codec) Init() {}

func (c ast_RangeStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.RangeStmt)
	c.encode(e, &s)
}

func (c ast_RangeStmt_codec) encode(e *codecapi.Encoder, x *ast.RangeStmt) {
	e.StartStruct()
	if x.For != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.For))
	}
	if x.Key != nil {
		e.EncodeUint(1)
		e.EncodeAny(x.Key)
	}
	if x.Value != nil {
		e.EncodeUint(2)
		e.EncodeAny(x.Value)
	}
	if x.TokPos != 0 {
		e.EncodeUint(3)
		e.EncodeInt(int64(x.TokPos))
	}
	if x.Tok != 0 {
		e.EncodeUint(4)
		e.EncodeInt(int64(x.Tok))
	}
	if x.X != nil {
		e.EncodeUint(5)
		e.EncodeAny(x.X)
	}
	if x.Body != nil {
		e.EncodeUint(6)
		(ptr_ast_BlockStmt_codec{}).encode(e, x.Body)
	}
	e.EndStruct()
}

func (c ast_RangeStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.RangeStmt
	c.decode(d, &x)
	return x
}

func (c ast_RangeStmt_codec) decode(d *codecapi.Decoder, x *ast.RangeStmt) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.For = token.Pos(d.DecodeInt())
		case 1:
			x.Key = d.DecodeAny().(ast.Expr)
		case 2:
			x.Value = d.DecodeAny().(ast.Expr)
		case 3:
			x.TokPos = token.Pos(d.DecodeInt())
		case 4:
			x.Tok = token.Token(d.DecodeInt())
		case 5:
			x.X = d.DecodeAny().(ast.Expr)
		case 6:
			(ptr_ast_BlockStmt_codec{}).decode(d, &x.Body)
		default:
			d.UnknownField("ast.RangeStmt", n)
		}
	}
}

func init() {
	codecapi.Register(ast.RangeStmt{}, ast_RangeStmt_codec{})
	codecapi.Register(&ast.RangeStmt{}, ptr_ast_RangeStmt_codec{})
}

// Fields of ast_ReturnStmt: Return Results

type ptr_ast_ReturnStmt_codec struct{}

func (ptr_ast_ReturnStmt_codec) Init() {}

func (c ptr_ast_ReturnStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.ReturnStmt))
}

func (c ptr_ast_ReturnStmt_codec) encode(e *codecapi.Encoder, x *ast.ReturnStmt) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_ReturnStmt_codec{}).encode(e, x)
}

func (c ptr_ast_ReturnStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.ReturnStmt
	c.decode(d, &x)
	return x
}

func (c ptr_ast_ReturnStmt_codec) decode(d *codecapi.Decoder, p **ast.ReturnStmt) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.ReturnStmt)
		return
	}
	var x ast.ReturnStmt
	d.StoreRef(&x)
	(ast_ReturnStmt_codec{}).decode(d, &x)
	*p = &x
}

type ast_ReturnStmt_codec struct{}

func (ast_ReturnStmt_codec) Init() {}

func (c ast_ReturnStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.ReturnStmt)
	c.encode(e, &s)
}

func (c ast_ReturnStmt_codec) encode(e *codecapi.Encoder, x *ast.ReturnStmt) {
	e.StartStruct()
	if x.Return != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.Return))
	}
	if x.Results != nil {
		e.EncodeUint(1)
		(slice_ast_Expr_codec{}).encode(e, x.Results)
	}
	e.EndStruct()
}

func (c ast_ReturnStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.ReturnStmt
	c.decode(d, &x)
	return x
}

func (c ast_ReturnStmt_codec) decode(d *codecapi.Decoder, x *ast.ReturnStmt) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Return = token.Pos(d.DecodeInt())
		case 1:
			(slice_ast_Expr_codec{}).decode(d, &x.Results)
		default:
			d.UnknownField("ast.ReturnStmt", n)
		}
	}
}

func init() {
	codecapi.Register(ast.ReturnStmt{}, ast_ReturnStmt_codec{})
	codecapi.Register(&ast.ReturnStmt{}, ptr_ast_ReturnStmt_codec{})
}

// Fields of ast_Scope: Outer Objects

type ptr_ast_Scope_codec struct{}

func (ptr_ast_Scope_codec) Init() {}

func (c ptr_ast_Scope_codec) Encode(e *codecapi.Encoder, x interface{}) { c.encode(e, x.(*ast.Scope)) }

func (c ptr_ast_Scope_codec) encode(e *codecapi.Encoder, x *ast.Scope) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_Scope_codec{}).encode(e, x)
}

func (c ptr_ast_Scope_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.Scope
	c.decode(d, &x)
	return x
}

func (c ptr_ast_Scope_codec) decode(d *codecapi.Decoder, p **ast.Scope) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.Scope)
		return
	}
	var x ast.Scope
	d.StoreRef(&x)
	(ast_Scope_codec{}).decode(d, &x)
	*p = &x
}

type ast_Scope_codec struct{}

func (ast_Scope_codec) Init() {}

func (c ast_Scope_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.Scope)
	c.encode(e, &s)
}

func (c ast_Scope_codec) encode(e *codecapi.Encoder, x *ast.Scope) {
	e.StartStruct()
	if x.Outer != nil {
		e.EncodeUint(0)
		(ptr_ast_Scope_codec{}).encode(e, x.Outer)
	}
	if x.Objects != nil {
		e.EncodeUint(1)
		(map_string_ptr_ast_Object_codec{}).encode(e, x.Objects)
	}
	e.EndStruct()
}

func (c ast_Scope_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.Scope
	c.decode(d, &x)
	return x
}

func (c ast_Scope_codec) decode(d *codecapi.Decoder, x *ast.Scope) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			(ptr_ast_Scope_codec{}).decode(d, &x.Outer)
		case 1:
			(map_string_ptr_ast_Object_codec{}).decode(d, &x.Objects)
		default:
			d.UnknownField("ast.Scope", n)
		}
	}
}

func init() {
	codecapi.Register(ast.Scope{}, ast_Scope_codec{})
	codecapi.Register(&ast.Scope{}, ptr_ast_Scope_codec{})
}

// Fields of ast_SelectStmt: Select Body

type ptr_ast_SelectStmt_codec struct{}

func (ptr_ast_SelectStmt_codec) Init() {}

func (c ptr_ast_SelectStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.SelectStmt))
}

func (c ptr_ast_SelectStmt_codec) encode(e *codecapi.Encoder, x *ast.SelectStmt) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_SelectStmt_codec{}).encode(e, x)
}

func (c ptr_ast_SelectStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.SelectStmt
	c.decode(d, &x)
	return x
}

func (c ptr_ast_SelectStmt_codec) decode(d *codecapi.Decoder, p **ast.SelectStmt) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.SelectStmt)
		return
	}
	var x ast.SelectStmt
	d.StoreRef(&x)
	(ast_SelectStmt_codec{}).decode(d, &x)
	*p = &x
}

type ast_SelectStmt_codec struct{}

func (ast_SelectStmt_codec) Init() {}

func (c ast_SelectStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.SelectStmt)
	c.encode(e, &s)
}

func (c ast_SelectStmt_codec) encode(e *codecapi.Encoder, x *ast.SelectStmt) {
	e.StartStruct()
	if x.Select != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.Select))
	}
	if x.Body != nil {
		e.EncodeUint(1)
		(ptr_ast_BlockStmt_codec{}).encode(e, x.Body)
	}
	e.EndStruct()
}

func (c ast_SelectStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.SelectStmt
	c.decode(d, &x)
	return x
}

func (c ast_SelectStmt_codec) decode(d *codecapi.Decoder, x *ast.SelectStmt) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Select = token.Pos(d.DecodeInt())
		case 1:
			(ptr_ast_BlockStmt_codec{}).decode(d, &x.Body)
		default:
			d.UnknownField("ast.SelectStmt", n)
		}
	}
}

func init() {
	codecapi.Register(ast.SelectStmt{}, ast_SelectStmt_codec{})
	codecapi.Register(&ast.SelectStmt{}, ptr_ast_SelectStmt_codec{})
}

// Fields of ast_SelectorExpr: X Sel

type ptr_ast_SelectorExpr_codec struct{}

func (ptr_ast_SelectorExpr_codec) Init() {}

func (c ptr_ast_SelectorExpr_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.SelectorExpr))
}

func (c ptr_ast_SelectorExpr_codec) encode(e *codecapi.Encoder, x *ast.SelectorExpr) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_SelectorExpr_codec{}).encode(e, x)
}

func (c ptr_ast_SelectorExpr_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.SelectorExpr
	c.decode(d, &x)
	return x
}

func (c ptr_ast_SelectorExpr_codec) decode(d *codecapi.Decoder, p **ast.SelectorExpr) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.SelectorExpr)
		return
	}
	var x ast.SelectorExpr
	d.StoreRef(&x)
	(ast_SelectorExpr_codec{}).decode(d, &x)
	*p = &x
}

type ast_SelectorExpr_codec struct{}

func (ast_SelectorExpr_codec) Init() {}

func (c ast_SelectorExpr_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.SelectorExpr)
	c.encode(e, &s)
}

func (c ast_SelectorExpr_codec) encode(e *codecapi.Encoder, x *ast.SelectorExpr) {
	e.StartStruct()
	if x.X != nil {
		e.EncodeUint(0)
		e.EncodeAny(x.X)
	}
	if x.Sel != nil {
		e.EncodeUint(1)
		(ptr_ast_Ident_codec{}).encode(e, x.Sel)
	}
	e.EndStruct()
}

func (c ast_SelectorExpr_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.SelectorExpr
	c.decode(d, &x)
	return x
}

func (c ast_SelectorExpr_codec) decode(d *codecapi.Decoder, x *ast.SelectorExpr) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.X = d.DecodeAny().(ast.Expr)
		case 1:
			(ptr_ast_Ident_codec{}).decode(d, &x.Sel)
		default:
			d.UnknownField("ast.SelectorExpr", n)
		}
	}
}

func init() {
	codecapi.Register(ast.SelectorExpr{}, ast_SelectorExpr_codec{})
	codecapi.Register(&ast.SelectorExpr{}, ptr_ast_SelectorExpr_codec{})
}

// Fields of ast_SendStmt: Chan Arrow Value

type ptr_ast_SendStmt_codec struct{}

func (ptr_ast_SendStmt_codec) Init() {}

func (c ptr_ast_SendStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.SendStmt))
}

func (c ptr_ast_SendStmt_codec) encode(e *codecapi.Encoder, x *ast.SendStmt) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_SendStmt_codec{}).encode(e, x)
}

func (c ptr_ast_SendStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.SendStmt
	c.decode(d, &x)
	return x
}

func (c ptr_ast_SendStmt_codec) decode(d *codecapi.Decoder, p **ast.SendStmt) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.SendStmt)
		return
	}
	var x ast.SendStmt
	d.StoreRef(&x)
	(ast_SendStmt_codec{}).decode(d, &x)
	*p = &x
}

type ast_SendStmt_codec struct{}

func (ast_SendStmt_codec) Init() {}

func (c ast_SendStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.SendStmt)
	c.encode(e, &s)
}

func (c ast_SendStmt_codec) encode(e *codecapi.Encoder, x *ast.SendStmt) {
	e.StartStruct()
	if x.Chan != nil {
		e.EncodeUint(0)
		e.EncodeAny(x.Chan)
	}
	if x.Arrow != 0 {
		e.EncodeUint(1)
		e.EncodeInt(int64(x.Arrow))
	}
	if x.Value != nil {
		e.EncodeUint(2)
		e.EncodeAny(x.Value)
	}
	e.EndStruct()
}

func (c ast_SendStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.SendStmt
	c.decode(d, &x)
	return x
}

func (c ast_SendStmt_codec) decode(d *codecapi.Decoder, x *ast.SendStmt) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Chan = d.DecodeAny().(ast.Expr)
		case 1:
			x.Arrow = token.Pos(d.DecodeInt())
		case 2:
			x.Value = d.DecodeAny().(ast.Expr)
		default:
			d.UnknownField("ast.SendStmt", n)
		}
	}
}

func init() {
	codecapi.Register(ast.SendStmt{}, ast_SendStmt_codec{})
	codecapi.Register(&ast.SendStmt{}, ptr_ast_SendStmt_codec{})
}

// Fields of ast_SliceExpr: X Lbrack Low High Max Slice3 Rbrack

type ptr_ast_SliceExpr_codec struct{}

func (ptr_ast_SliceExpr_codec) Init() {}

func (c ptr_ast_SliceExpr_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.SliceExpr))
}

func (c ptr_ast_SliceExpr_codec) encode(e *codecapi.Encoder, x *ast.SliceExpr) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_SliceExpr_codec{}).encode(e, x)
}

func (c ptr_ast_SliceExpr_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.SliceExpr
	c.decode(d, &x)
	return x
}

func (c ptr_ast_SliceExpr_codec) decode(d *codecapi.Decoder, p **ast.SliceExpr) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.SliceExpr)
		return
	}
	var x ast.SliceExpr
	d.StoreRef(&x)
	(ast_SliceExpr_codec{}).decode(d, &x)
	*p = &x
}

type ast_SliceExpr_codec struct{}

func (ast_SliceExpr_codec) Init() {}

func (c ast_SliceExpr_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.SliceExpr)
	c.encode(e, &s)
}

func (c ast_SliceExpr_codec) encode(e *codecapi.Encoder, x *ast.SliceExpr) {
	e.StartStruct()
	if x.X != nil {
		e.EncodeUint(0)
		e.EncodeAny(x.X)
	}
	if x.Lbrack != 0 {
		e.EncodeUint(1)
		e.EncodeInt(int64(x.Lbrack))
	}
	if x.Low != nil {
		e.EncodeUint(2)
		e.EncodeAny(x.Low)
	}
	if x.High != nil {
		e.EncodeUint(3)
		e.EncodeAny(x.High)
	}
	if x.Max != nil {
		e.EncodeUint(4)
		e.EncodeAny(x.Max)
	}
	if x.Slice3 != false {
		e.EncodeUint(5)
		e.EncodeBool(x.Slice3)
	}
	if x.Rbrack != 0 {
		e.EncodeUint(6)
		e.EncodeInt(int64(x.Rbrack))
	}
	e.EndStruct()
}

func (c ast_SliceExpr_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.SliceExpr
	c.decode(d, &x)
	return x
}

func (c ast_SliceExpr_codec) decode(d *codecapi.Decoder, x *ast.SliceExpr) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.X = d.DecodeAny().(ast.Expr)
		case 1:
			x.Lbrack = token.Pos(d.DecodeInt())
		case 2:
			x.Low = d.DecodeAny().(ast.Expr)
		case 3:
			x.High = d.DecodeAny().(ast.Expr)
		case 4:
			x.Max = d.DecodeAny().(ast.Expr)
		case 5:
			x.Slice3 = d.DecodeBool()
		case 6:
			x.Rbrack = token.Pos(d.DecodeInt())
		default:
			d.UnknownField("ast.SliceExpr", n)
		}
	}
}

func init() {
	codecapi.Register(ast.SliceExpr{}, ast_SliceExpr_codec{})
	codecapi.Register(&ast.SliceExpr{}, ptr_ast_SliceExpr_codec{})
}

// Fields of ast_StarExpr: Star X

type ptr_ast_StarExpr_codec struct{}

func (ptr_ast_StarExpr_codec) Init() {}

func (c ptr_ast_StarExpr_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.StarExpr))
}

func (c ptr_ast_StarExpr_codec) encode(e *codecapi.Encoder, x *ast.StarExpr) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_StarExpr_codec{}).encode(e, x)
}

func (c ptr_ast_StarExpr_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.StarExpr
	c.decode(d, &x)
	return x
}

func (c ptr_ast_StarExpr_codec) decode(d *codecapi.Decoder, p **ast.StarExpr) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.StarExpr)
		return
	}
	var x ast.StarExpr
	d.StoreRef(&x)
	(ast_StarExpr_codec{}).decode(d, &x)
	*p = &x
}

type ast_StarExpr_codec struct{}

func (ast_StarExpr_codec) Init() {}

func (c ast_StarExpr_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.StarExpr)
	c.encode(e, &s)
}

func (c ast_StarExpr_codec) encode(e *codecapi.Encoder, x *ast.StarExpr) {
	e.StartStruct()
	if x.Star != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.Star))
	}
	if x.X != nil {
		e.EncodeUint(1)
		e.EncodeAny(x.X)
	}
	e.EndStruct()
}

func (c ast_StarExpr_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.StarExpr
	c.decode(d, &x)
	return x
}

func (c ast_StarExpr_codec) decode(d *codecapi.Decoder, x *ast.StarExpr) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Star = token.Pos(d.DecodeInt())
		case 1:
			x.X = d.DecodeAny().(ast.Expr)
		default:
			d.UnknownField("ast.StarExpr", n)
		}
	}
}

func init() {
	codecapi.Register(ast.StarExpr{}, ast_StarExpr_codec{})
	codecapi.Register(&ast.StarExpr{}, ptr_ast_StarExpr_codec{})
}

// Fields of ast_StructType: Struct Fields Incomplete

type ptr_ast_StructType_codec struct{}

func (ptr_ast_StructType_codec) Init() {}

func (c ptr_ast_StructType_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.StructType))
}

func (c ptr_ast_StructType_codec) encode(e *codecapi.Encoder, x *ast.StructType) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_StructType_codec{}).encode(e, x)
}

func (c ptr_ast_StructType_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.StructType
	c.decode(d, &x)
	return x
}

func (c ptr_ast_StructType_codec) decode(d *codecapi.Decoder, p **ast.StructType) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.StructType)
		return
	}
	var x ast.StructType
	d.StoreRef(&x)
	(ast_StructType_codec{}).decode(d, &x)
	*p = &x
}

type ast_StructType_codec struct{}

func (ast_StructType_codec) Init() {}

func (c ast_StructType_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.StructType)
	c.encode(e, &s)
}

func (c ast_StructType_codec) encode(e *codecapi.Encoder, x *ast.StructType) {
	e.StartStruct()
	if x.Struct != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.Struct))
	}
	if x.Fields != nil {
		e.EncodeUint(1)
		(ptr_ast_FieldList_codec{}).encode(e, x.Fields)
	}
	if x.Incomplete != false {
		e.EncodeUint(2)
		e.EncodeBool(x.Incomplete)
	}
	e.EndStruct()
}

func (c ast_StructType_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.StructType
	c.decode(d, &x)
	return x
}

func (c ast_StructType_codec) decode(d *codecapi.Decoder, x *ast.StructType) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Struct = token.Pos(d.DecodeInt())
		case 1:
			(ptr_ast_FieldList_codec{}).decode(d, &x.Fields)
		case 2:
			x.Incomplete = d.DecodeBool()
		default:
			d.UnknownField("ast.StructType", n)
		}
	}
}

func init() {
	codecapi.Register(ast.StructType{}, ast_StructType_codec{})
	codecapi.Register(&ast.StructType{}, ptr_ast_StructType_codec{})
}

// Fields of ast_SwitchStmt: Switch Init Tag Body

type ptr_ast_SwitchStmt_codec struct{}

func (ptr_ast_SwitchStmt_codec) Init() {}

func (c ptr_ast_SwitchStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.SwitchStmt))
}

func (c ptr_ast_SwitchStmt_codec) encode(e *codecapi.Encoder, x *ast.SwitchStmt) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_SwitchStmt_codec{}).encode(e, x)
}

func (c ptr_ast_SwitchStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.SwitchStmt
	c.decode(d, &x)
	return x
}

func (c ptr_ast_SwitchStmt_codec) decode(d *codecapi.Decoder, p **ast.SwitchStmt) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.SwitchStmt)
		return
	}
	var x ast.SwitchStmt
	d.StoreRef(&x)
	(ast_SwitchStmt_codec{}).decode(d, &x)
	*p = &x
}

type ast_SwitchStmt_codec struct{}

func (ast_SwitchStmt_codec) Init() {}

func (c ast_SwitchStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.SwitchStmt)
	c.encode(e, &s)
}

func (c ast_SwitchStmt_codec) encode(e *codecapi.Encoder, x *ast.SwitchStmt) {
	e.StartStruct()
	if x.Switch != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.Switch))
	}
	if x.Init != nil {
		e.EncodeUint(1)
		e.EncodeAny(x.Init)
	}
	if x.Tag != nil {
		e.EncodeUint(2)
		e.EncodeAny(x.Tag)
	}
	if x.Body != nil {
		e.EncodeUint(3)
		(ptr_ast_BlockStmt_codec{}).encode(e, x.Body)
	}
	e.EndStruct()
}

func (c ast_SwitchStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.SwitchStmt
	c.decode(d, &x)
	return x
}

func (c ast_SwitchStmt_codec) decode(d *codecapi.Decoder, x *ast.SwitchStmt) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Switch = token.Pos(d.DecodeInt())
		case 1:
			x.Init = d.DecodeAny().(ast.Stmt)
		case 2:
			x.Tag = d.DecodeAny().(ast.Expr)
		case 3:
			(ptr_ast_BlockStmt_codec{}).decode(d, &x.Body)
		default:
			d.UnknownField("ast.SwitchStmt", n)
		}
	}
}

func init() {
	codecapi.Register(ast.SwitchStmt{}, ast_SwitchStmt_codec{})
	codecapi.Register(&ast.SwitchStmt{}, ptr_ast_SwitchStmt_codec{})
}

// Fields of ast_TypeAssertExpr: X Lparen Type Rparen

type ptr_ast_TypeAssertExpr_codec struct{}

func (ptr_ast_TypeAssertExpr_codec) Init() {}

func (c ptr_ast_TypeAssertExpr_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.TypeAssertExpr))
}

func (c ptr_ast_TypeAssertExpr_codec) encode(e *codecapi.Encoder, x *ast.TypeAssertExpr) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_TypeAssertExpr_codec{}).encode(e, x)
}

func (c ptr_ast_TypeAssertExpr_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.TypeAssertExpr
	c.decode(d, &x)
	return x
}

func (c ptr_ast_TypeAssertExpr_codec) decode(d *codecapi.Decoder, p **ast.TypeAssertExpr) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.TypeAssertExpr)
		return
	}
	var x ast.TypeAssertExpr
	d.StoreRef(&x)
	(ast_TypeAssertExpr_codec{}).decode(d, &x)
	*p = &x
}

type ast_TypeAssertExpr_codec struct{}

func (ast_TypeAssertExpr_codec) Init() {}

func (c ast_TypeAssertExpr_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.TypeAssertExpr)
	c.encode(e, &s)
}

func (c ast_TypeAssertExpr_codec) encode(e *codecapi.Encoder, x *ast.TypeAssertExpr) {
	e.StartStruct()
	if x.X != nil {
		e.EncodeUint(0)
		e.EncodeAny(x.X)
	}
	if x.Lparen != 0 {
		e.EncodeUint(1)
		e.EncodeInt(int64(x.Lparen))
	}
	if x.Type != nil {
		e.EncodeUint(2)
		e.EncodeAny(x.Type)
	}
	if x.Rparen != 0 {
		e.EncodeUint(3)
		e.EncodeInt(int64(x.Rparen))
	}
	e.EndStruct()
}

func (c ast_TypeAssertExpr_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.TypeAssertExpr
	c.decode(d, &x)
	return x
}

func (c ast_TypeAssertExpr_codec) decode(d *codecapi.Decoder, x *ast.TypeAssertExpr) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.X = d.DecodeAny().(ast.Expr)
		case 1:
			x.Lparen = token.Pos(d.DecodeInt())
		case 2:
			x.Type = d.DecodeAny().(ast.Expr)
		case 3:
			x.Rparen = token.Pos(d.DecodeInt())
		default:
			d.UnknownField("ast.TypeAssertExpr", n)
		}
	}
}

func init() {
	codecapi.Register(ast.TypeAssertExpr{}, ast_TypeAssertExpr_codec{})
	codecapi.Register(&ast.TypeAssertExpr{}, ptr_ast_TypeAssertExpr_codec{})
}

// Fields of ast_TypeSpec: Doc Name Assign Type Comment

type ptr_ast_TypeSpec_codec struct{}

func (ptr_ast_TypeSpec_codec) Init() {}

func (c ptr_ast_TypeSpec_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.TypeSpec))
}

func (c ptr_ast_TypeSpec_codec) encode(e *codecapi.Encoder, x *ast.TypeSpec) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_TypeSpec_codec{}).encode(e, x)
}

func (c ptr_ast_TypeSpec_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.TypeSpec
	c.decode(d, &x)
	return x
}

func (c ptr_ast_TypeSpec_codec) decode(d *codecapi.Decoder, p **ast.TypeSpec) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.TypeSpec)
		return
	}
	var x ast.TypeSpec
	d.StoreRef(&x)
	(ast_TypeSpec_codec{}).decode(d, &x)
	*p = &x
}

type ast_TypeSpec_codec struct{}

func (ast_TypeSpec_codec) Init() {}

func (c ast_TypeSpec_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.TypeSpec)
	c.encode(e, &s)
}

func (c ast_TypeSpec_codec) encode(e *codecapi.Encoder, x *ast.TypeSpec) {
	e.StartStruct()
	if x.Doc != nil {
		e.EncodeUint(0)
		(ptr_ast_CommentGroup_codec{}).encode(e, x.Doc)
	}
	if x.Name != nil {
		e.EncodeUint(1)
		(ptr_ast_Ident_codec{}).encode(e, x.Name)
	}
	if x.Assign != 0 {
		e.EncodeUint(2)
		e.EncodeInt(int64(x.Assign))
	}
	if x.Type != nil {
		e.EncodeUint(3)
		e.EncodeAny(x.Type)
	}
	if x.Comment != nil {
		e.EncodeUint(4)
		(ptr_ast_CommentGroup_codec{}).encode(e, x.Comment)
	}
	e.EndStruct()
}

func (c ast_TypeSpec_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.TypeSpec
	c.decode(d, &x)
	return x
}

func (c ast_TypeSpec_codec) decode(d *codecapi.Decoder, x *ast.TypeSpec) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			(ptr_ast_CommentGroup_codec{}).decode(d, &x.Doc)
		case 1:
			(ptr_ast_Ident_codec{}).decode(d, &x.Name)
		case 2:
			x.Assign = token.Pos(d.DecodeInt())
		case 3:
			x.Type = d.DecodeAny().(ast.Expr)
		case 4:
			(ptr_ast_CommentGroup_codec{}).decode(d, &x.Comment)
		default:
			d.UnknownField("ast.TypeSpec", n)
		}
	}
}

func init() {
	codecapi.Register(ast.TypeSpec{}, ast_TypeSpec_codec{})
	codecapi.Register(&ast.TypeSpec{}, ptr_ast_TypeSpec_codec{})
}

// Fields of ast_TypeSwitchStmt: Switch Init Assign Body

type ptr_ast_TypeSwitchStmt_codec struct{}

func (ptr_ast_TypeSwitchStmt_codec) Init() {}

func (c ptr_ast_TypeSwitchStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.TypeSwitchStmt))
}

func (c ptr_ast_TypeSwitchStmt_codec) encode(e *codecapi.Encoder, x *ast.TypeSwitchStmt) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_TypeSwitchStmt_codec{}).encode(e, x)
}

func (c ptr_ast_TypeSwitchStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.TypeSwitchStmt
	c.decode(d, &x)
	return x
}

func (c ptr_ast_TypeSwitchStmt_codec) decode(d *codecapi.Decoder, p **ast.TypeSwitchStmt) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.TypeSwitchStmt)
		return
	}
	var x ast.TypeSwitchStmt
	d.StoreRef(&x)
	(ast_TypeSwitchStmt_codec{}).decode(d, &x)
	*p = &x
}

type ast_TypeSwitchStmt_codec struct{}

func (ast_TypeSwitchStmt_codec) Init() {}

func (c ast_TypeSwitchStmt_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.TypeSwitchStmt)
	c.encode(e, &s)
}

func (c ast_TypeSwitchStmt_codec) encode(e *codecapi.Encoder, x *ast.TypeSwitchStmt) {
	e.StartStruct()
	if x.Switch != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.Switch))
	}
	if x.Init != nil {
		e.EncodeUint(1)
		e.EncodeAny(x.Init)
	}
	if x.Assign != nil {
		e.EncodeUint(2)
		e.EncodeAny(x.Assign)
	}
	if x.Body != nil {
		e.EncodeUint(3)
		(ptr_ast_BlockStmt_codec{}).encode(e, x.Body)
	}
	e.EndStruct()
}

func (c ast_TypeSwitchStmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.TypeSwitchStmt
	c.decode(d, &x)
	return x
}

func (c ast_TypeSwitchStmt_codec) decode(d *codecapi.Decoder, x *ast.TypeSwitchStmt) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Switch = token.Pos(d.DecodeInt())
		case 1:
			x.Init = d.DecodeAny().(ast.Stmt)
		case 2:
			x.Assign = d.DecodeAny().(ast.Stmt)
		case 3:
			(ptr_ast_BlockStmt_codec{}).decode(d, &x.Body)
		default:
			d.UnknownField("ast.TypeSwitchStmt", n)
		}
	}
}

func init() {
	codecapi.Register(ast.TypeSwitchStmt{}, ast_TypeSwitchStmt_codec{})
	codecapi.Register(&ast.TypeSwitchStmt{}, ptr_ast_TypeSwitchStmt_codec{})
}

// Fields of ast_UnaryExpr: OpPos Op X

type ptr_ast_UnaryExpr_codec struct{}

func (ptr_ast_UnaryExpr_codec) Init() {}

func (c ptr_ast_UnaryExpr_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.UnaryExpr))
}

func (c ptr_ast_UnaryExpr_codec) encode(e *codecapi.Encoder, x *ast.UnaryExpr) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_UnaryExpr_codec{}).encode(e, x)
}

func (c ptr_ast_UnaryExpr_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.UnaryExpr
	c.decode(d, &x)
	return x
}

func (c ptr_ast_UnaryExpr_codec) decode(d *codecapi.Decoder, p **ast.UnaryExpr) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.UnaryExpr)
		return
	}
	var x ast.UnaryExpr
	d.StoreRef(&x)
	(ast_UnaryExpr_codec{}).decode(d, &x)
	*p = &x
}

type ast_UnaryExpr_codec struct{}

func (ast_UnaryExpr_codec) Init() {}

func (c ast_UnaryExpr_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.UnaryExpr)
	c.encode(e, &s)
}

func (c ast_UnaryExpr_codec) encode(e *codecapi.Encoder, x *ast.UnaryExpr) {
	e.StartStruct()
	if x.OpPos != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.OpPos))
	}
	if x.Op != 0 {
		e.EncodeUint(1)
		e.EncodeInt(int64(x.Op))
	}
	if x.X != nil {
		e.EncodeUint(2)
		e.EncodeAny(x.X)
	}
	e.EndStruct()
}

func (c ast_UnaryExpr_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.UnaryExpr
	c.decode(d, &x)
	return x
}

func (c ast_UnaryExpr_codec) decode(d *codecapi.Decoder, x *ast.UnaryExpr) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.OpPos = token.Pos(d.DecodeInt())
		case 1:
			x.Op = token.Token(d.DecodeInt())
		case 2:
			x.X = d.DecodeAny().(ast.Expr)
		default:
			d.UnknownField("ast.UnaryExpr", n)
		}
	}
}

func init() {
	codecapi.Register(ast.UnaryExpr{}, ast_UnaryExpr_codec{})
	codecapi.Register(&ast.UnaryExpr{}, ptr_ast_UnaryExpr_codec{})
}

// Fields of ast_ValueSpec: Doc Names Type Values Comment

type ptr_ast_ValueSpec_codec struct{}

func (ptr_ast_ValueSpec_codec) Init() {}

func (c ptr_ast_ValueSpec_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.ValueSpec))
}

func (c ptr_ast_ValueSpec_codec) encode(e *codecapi.Encoder, x *ast.ValueSpec) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_ValueSpec_codec{}).encode(e, x)
}

func (c ptr_ast_ValueSpec_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.ValueSpec
	c.decode(d, &x)
	return x
}

func (c ptr_ast_ValueSpec_codec) decode(d *codecapi.Decoder, p **ast.ValueSpec) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.ValueSpec)
		return
	}
	var x ast.ValueSpec
	d.StoreRef(&x)
	(ast_ValueSpec_codec{}).decode(d, &x)
	*p = &x
}

type ast_ValueSpec_codec struct{}

func (ast_ValueSpec_codec) Init() {}

func (c ast_ValueSpec_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.ValueSpec)
	c.encode(e, &s)
}

func (c ast_ValueSpec_codec) encode(e *codecapi.Encoder, x *ast.ValueSpec) {
	e.StartStruct()
	if x.Doc != nil {
		e.EncodeUint(0)
		(ptr_ast_CommentGroup_codec{}).encode(e, x.Doc)
	}
	if x.Names != nil {
		e.EncodeUint(1)
		(slice_ptr_ast_Ident_codec{}).encode(e, x.Names)
	}
	if x.Type != nil {
		e.EncodeUint(2)
		e.EncodeAny(x.Type)
	}
	if x.Values != nil {
		e.EncodeUint(3)
		(slice_ast_Expr_codec{}).encode(e, x.Values)
	}
	if x.Comment != nil {
		e.EncodeUint(4)
		(ptr_ast_CommentGroup_codec{}).encode(e, x.Comment)
	}
	e.EndStruct()
}

func (c ast_ValueSpec_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.ValueSpec
	c.decode(d, &x)
	return x
}

func (c ast_ValueSpec_codec) decode(d *codecapi.Decoder, x *ast.ValueSpec) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			(ptr_ast_CommentGroup_codec{}).decode(d, &x.Doc)
		case 1:
			(slice_ptr_ast_Ident_codec{}).decode(d, &x.Names)
		case 2:
			x.Type = d.DecodeAny().(ast.Expr)
		case 3:
			(slice_ast_Expr_codec{}).decode(d, &x.Values)
		case 4:
			(ptr_ast_CommentGroup_codec{}).decode(d, &x.Comment)
		default:
			d.UnknownField("ast.ValueSpec", n)
		}
	}
}

func init() {
	codecapi.Register(ast.ValueSpec{}, ast_ValueSpec_codec{})
	codecapi.Register(&ast.ValueSpec{}, ptr_ast_ValueSpec_codec{})
}

type map_string_ptr_ast_File_codec struct{}

func (c map_string_ptr_ast_File_codec) Init() {}

func (c map_string_ptr_ast_File_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(map[string]*ast.File))
}

func (c map_string_ptr_ast_File_codec) encode(e *codecapi.Encoder, m map[string]*ast.File) {
	if m == nil {
		e.EncodeNil()
		return
	}
	e.StartList(2 * len(m))
	for k, v := range m {
		e.EncodeString(k)
		(ptr_ast_File_codec{}).encode(e, v)
	}
}

func (c map_string_ptr_ast_File_codec) Decode(d *codecapi.Decoder) interface{} {
	var x map[string]*ast.File
	c.decode(d, &x)
	return x
}

func (c map_string_ptr_ast_File_codec) decode(d *codecapi.Decoder, p *map[string]*ast.File) {
	n2 := d.StartList()
	if n2 < 0 {
		return
	}
	n := n2 / 2
	m := make(map[string]*ast.File, n)
	var k string
	var v *ast.File
	for i := 0; i < n; i++ {
		k = d.DecodeString()
		(ptr_ast_File_codec{}).decode(d, &v)
		m[k] = v
	}
	*p = m
}

func init() { codecapi.Register(map[string]*ast.File(nil), map_string_ptr_ast_File_codec{}) }

type slice_ast_Expr_codec struct{}

func (slice_ast_Expr_codec) Init() {}

func (c slice_ast_Expr_codec) Encode(e *codecapi.Encoder, x interface{}) { c.encode(e, x.([]ast.Expr)) }

func (c slice_ast_Expr_codec) encode(e *codecapi.Encoder, s []ast.Expr) {
	if s == nil {
		e.EncodeNil()
		return
	}
	e.StartList(len(s))
	for _, x := range s {
		e.EncodeAny(x)
	}
}

func (c slice_ast_Expr_codec) Decode(d *codecapi.Decoder) interface{} {
	var x []ast.Expr
	c.decode(d, &x)
	return x
}

func (c slice_ast_Expr_codec) decode(d *codecapi.Decoder, p *[]ast.Expr) {
	n := d.StartList()
	if n < 0 {
		return
	}
	s := make([]ast.Expr, n)
	for i := 0; i < n; i++ {
		s[i] = d.DecodeAny().(ast.Expr)
	}
	*p = s
}

func init() {
	codecapi.Register([]ast.Expr(nil), slice_ast_Expr_codec{})
}

type slice_ast_Stmt_codec struct{}

func (slice_ast_Stmt_codec) Init() {}

func (c slice_ast_Stmt_codec) Encode(e *codecapi.Encoder, x interface{}) { c.encode(e, x.([]ast.Stmt)) }

func (c slice_ast_Stmt_codec) encode(e *codecapi.Encoder, s []ast.Stmt) {
	if s == nil {
		e.EncodeNil()
		return
	}
	e.StartList(len(s))
	for _, x := range s {
		e.EncodeAny(x)
	}
}

func (c slice_ast_Stmt_codec) Decode(d *codecapi.Decoder) interface{} {
	var x []ast.Stmt
	c.decode(d, &x)
	return x
}

func (c slice_ast_Stmt_codec) decode(d *codecapi.Decoder, p *[]ast.Stmt) {
	n := d.StartList()
	if n < 0 {
		return
	}
	s := make([]ast.Stmt, n)
	for i := 0; i < n; i++ {
		s[i] = d.DecodeAny().(ast.Stmt)
	}
	*p = s
}

func init() {
	codecapi.Register([]ast.Stmt(nil), slice_ast_Stmt_codec{})
}

type slice_ptr_ast_Comment_codec struct{}

func (slice_ptr_ast_Comment_codec) Init() {}

func (c slice_ptr_ast_Comment_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.([]*ast.Comment))
}

func (c slice_ptr_ast_Comment_codec) encode(e *codecapi.Encoder, s []*ast.Comment) {
	if s == nil {
		e.EncodeNil()
		return
	}
	e.StartList(len(s))
	for _, x := range s {
		(ptr_ast_Comment_codec{}).encode(e, x)
	}
}

func (c slice_ptr_ast_Comment_codec) Decode(d *codecapi.Decoder) interface{} {
	var x []*ast.Comment
	c.decode(d, &x)
	return x
}

func (c slice_ptr_ast_Comment_codec) decode(d *codecapi.Decoder, p *[]*ast.Comment) {
	n := d.StartList()
	if n < 0 {
		return
	}
	s := make([]*ast.Comment, n)
	for i := 0; i < n; i++ {
		(ptr_ast_Comment_codec{}).decode(d, &s[i])
	}
	*p = s
}

func init() {
	codecapi.Register([]*ast.Comment(nil), slice_ptr_ast_Comment_codec{})
}

type slice_ptr_ast_Field_codec struct{}

func (slice_ptr_ast_Field_codec) Init() {}

func (c slice_ptr_ast_Field_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.([]*ast.Field))
}

func (c slice_ptr_ast_Field_codec) encode(e *codecapi.Encoder, s []*ast.Field) {
	if s == nil {
		e.EncodeNil()
		return
	}
	e.StartList(len(s))
	for _, x := range s {
		(ptr_ast_Field_codec{}).encode(e, x)
	}
}

func (c slice_ptr_ast_Field_codec) Decode(d *codecapi.Decoder) interface{} {
	var x []*ast.Field
	c.decode(d, &x)
	return x
}

func (c slice_ptr_ast_Field_codec) decode(d *codecapi.Decoder, p *[]*ast.Field) {
	n := d.StartList()
	if n < 0 {
		return
	}
	s := make([]*ast.Field, n)
	for i := 0; i < n; i++ {
		(ptr_ast_Field_codec{}).decode(d, &s[i])
	}
	*p = s
}

func init() {
	codecapi.Register([]*ast.Field(nil), slice_ptr_ast_Field_codec{})
}

type slice_ptr_ast_Ident_codec struct{}

func (slice_ptr_ast_Ident_codec) Init() {}

func (c slice_ptr_ast_Ident_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.([]*ast.Ident))
}

func (c slice_ptr_ast_Ident_codec) encode(e *codecapi.Encoder, s []*ast.Ident) {
	if s == nil {
		e.EncodeNil()
		return
	}
	e.StartList(len(s))
	for _, x := range s {
		(ptr_ast_Ident_codec{}).encode(e, x)
	}
}

func (c slice_ptr_ast_Ident_codec) Decode(d *codecapi.Decoder) interface{} {
	var x []*ast.Ident
	c.decode(d, &x)
	return x
}

func (c slice_ptr_ast_Ident_codec) decode(d *codecapi.Decoder, p *[]*ast.Ident) {
	n := d.StartList()
	if n < 0 {
		return
	}
	s := make([]*ast.Ident, n)
	for i := 0; i < n; i++ {
		(ptr_ast_Ident_codec{}).decode(d, &s[i])
	}
	*p = s
}

func init() {
	codecapi.Register([]*ast.Ident(nil), slice_ptr_ast_Ident_codec{})
}

type slice_ast_Spec_codec struct{}

func (slice_ast_Spec_codec) Init() {}

func (c slice_ast_Spec_codec) Encode(e *codecapi.Encoder, x interface{}) { c.encode(e, x.([]ast.Spec)) }

func (c slice_ast_Spec_codec) encode(e *codecapi.Encoder, s []ast.Spec) {
	if s == nil {
		e.EncodeNil()
		return
	}
	e.StartList(len(s))
	for _, x := range s {
		e.EncodeAny(x)
	}
}

func (c slice_ast_Spec_codec) Decode(d *codecapi.Decoder) interface{} {
	var x []ast.Spec
	c.decode(d, &x)
	return x
}

func (c slice_ast_Spec_codec) decode(d *codecapi.Decoder, p *[]ast.Spec) {
	n := d.StartList()
	if n < 0 {
		return
	}
	s := make([]ast.Spec, n)
	for i := 0; i < n; i++ {
		s[i] = d.DecodeAny().(ast.Spec)
	}
	*p = s
}

func init() {
	codecapi.Register([]ast.Spec(nil), slice_ast_Spec_codec{})
}

// Fields of ast_Object: Kind Name Decl Data Type

type ptr_ast_Object_codec struct{}

func (ptr_ast_Object_codec) Init() {}

func (c ptr_ast_Object_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(*ast.Object))
}

func (c ptr_ast_Object_codec) encode(e *codecapi.Encoder, x *ast.Object) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_Object_codec{}).encode(e, x)
}

func (c ptr_ast_Object_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.Object
	c.decode(d, &x)
	return x
}

func (c ptr_ast_Object_codec) decode(d *codecapi.Decoder, p **ast.Object) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.Object)
		return
	}
	var x ast.Object
	d.StoreRef(&x)
	(ast_Object_codec{}).decode(d, &x)
	*p = &x
}

type ast_Object_codec struct{}

func (ast_Object_codec) Init() {}

func (c ast_Object_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.Object)
	c.encode(e, &s)
}

func (c ast_Object_codec) encode(e *codecapi.Encoder, x *ast.Object) {
	e.StartStruct()
	if x.Kind != 0 {
		e.EncodeUint(0)
		e.EncodeInt(int64(x.Kind))
	}
	if x.Name != "" {
		e.EncodeUint(1)
		e.EncodeString(x.Name)
	}
	if x.Decl != nil {
		e.EncodeUint(2)
		e.EncodeAny(x.Decl)
	}
	if x.Data != nil {
		e.EncodeUint(3)
		e.EncodeAny(x.Data)
	}
	if x.Type != nil {
		e.EncodeUint(4)
		e.EncodeAny(x.Type)
	}
	e.EndStruct()
}

func (c ast_Object_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.Object
	c.decode(d, &x)
	return x
}

func (c ast_Object_codec) decode(d *codecapi.Decoder, x *ast.Object) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			x.Kind = ast.ObjKind(d.DecodeInt())
		case 1:
			x.Name = d.DecodeString()
		case 2:
			x.Decl = d.DecodeAny()
		case 3:
			x.Data = d.DecodeAny()
		case 4:
			x.Type = d.DecodeAny()
		default:
			d.UnknownField("ast.Object", n)
		}
	}
}

func init() {
	codecapi.Register(ast.Object{}, ast_Object_codec{})
	codecapi.Register(&ast.Object{}, ptr_ast_Object_codec{})
}

type map_string_ptr_ast_Object_codec struct{}

func (c map_string_ptr_ast_Object_codec) Init() {}

func (c map_string_ptr_ast_Object_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.(map[string]*ast.Object))
}

func (c map_string_ptr_ast_Object_codec) encode(e *codecapi.Encoder, m map[string]*ast.Object) {
	if m == nil {
		e.EncodeNil()
		return
	}
	e.StartList(2 * len(m))
	for k, v := range m {
		e.EncodeString(k)
		(ptr_ast_Object_codec{}).encode(e, v)
	}
}

func (c map_string_ptr_ast_Object_codec) Decode(d *codecapi.Decoder) interface{} {
	var x map[string]*ast.Object
	c.decode(d, &x)
	return x
}

func (c map_string_ptr_ast_Object_codec) decode(d *codecapi.Decoder, p *map[string]*ast.Object) {
	n2 := d.StartList()
	if n2 < 0 {
		return
	}
	n := n2 / 2
	m := make(map[string]*ast.Object, n)
	var k string
	var v *ast.Object
	for i := 0; i < n; i++ {
		k = d.DecodeString()
		(ptr_ast_Object_codec{}).decode(d, &v)
		m[k] = v
	}
	*p = m
}

func init() { codecapi.Register(map[string]*ast.Object(nil), map_string_ptr_ast_Object_codec{}) }

// Fields of ast_File: Doc Package Name Decls Scope Imports Unresolved Comments

type ptr_ast_File_codec struct{}

func (ptr_ast_File_codec) Init() {}

func (c ptr_ast_File_codec) Encode(e *codecapi.Encoder, x interface{}) { c.encode(e, x.(*ast.File)) }

func (c ptr_ast_File_codec) encode(e *codecapi.Encoder, x *ast.File) {
	if !e.StartPtr(x == nil, x) {
		return
	}
	(ast_File_codec{}).encode(e, x)
}

func (c ptr_ast_File_codec) Decode(d *codecapi.Decoder) interface{} {
	var x *ast.File
	c.decode(d, &x)
	return x
}

func (c ptr_ast_File_codec) decode(d *codecapi.Decoder, p **ast.File) {
	proceed, ref := d.StartPtr()
	if !proceed {
		return
	}
	if ref != nil {
		*p = ref.(*ast.File)
		return
	}
	var x ast.File
	d.StoreRef(&x)
	(ast_File_codec{}).decode(d, &x)
	*p = &x
}

type ast_File_codec struct{}

func (ast_File_codec) Init() {}

func (c ast_File_codec) Encode(e *codecapi.Encoder, x interface{}) {
	s := x.(ast.File)
	c.encode(e, &s)
}

func (c ast_File_codec) encode(e *codecapi.Encoder, x *ast.File) {
	e.StartStruct()
	if x.Doc != nil {
		e.EncodeUint(0)
		(ptr_ast_CommentGroup_codec{}).encode(e, x.Doc)
	}
	if x.Package != 0 {
		e.EncodeUint(1)
		e.EncodeInt(int64(x.Package))
	}
	if x.Name != nil {
		e.EncodeUint(2)
		(ptr_ast_Ident_codec{}).encode(e, x.Name)
	}
	if x.Decls != nil {
		e.EncodeUint(3)
		(slice_ast_Decl_codec{}).encode(e, x.Decls)
	}
	if x.Scope != nil {
		e.EncodeUint(4)
		(ptr_ast_Scope_codec{}).encode(e, x.Scope)
	}
	if x.Imports != nil {
		e.EncodeUint(5)
		(slice_ptr_ast_ImportSpec_codec{}).encode(e, x.Imports)
	}
	if x.Unresolved != nil {
		e.EncodeUint(6)
		(slice_ptr_ast_Ident_codec{}).encode(e, x.Unresolved)
	}
	if x.Comments != nil {
		e.EncodeUint(7)
		(slice_ptr_ast_CommentGroup_codec{}).encode(e, x.Comments)
	}
	e.EndStruct()
}

func (c ast_File_codec) Decode(d *codecapi.Decoder) interface{} {
	var x ast.File
	c.decode(d, &x)
	return x
}

func (c ast_File_codec) decode(d *codecapi.Decoder, x *ast.File) {
	d.StartStruct()
	for {
		n := d.NextStructField()
		if n < 0 {
			break
		}
		switch n {
		case 0:
			(ptr_ast_CommentGroup_codec{}).decode(d, &x.Doc)
		case 1:
			x.Package = token.Pos(d.DecodeInt())
		case 2:
			(ptr_ast_Ident_codec{}).decode(d, &x.Name)
		case 3:
			(slice_ast_Decl_codec{}).decode(d, &x.Decls)
		case 4:
			(ptr_ast_Scope_codec{}).decode(d, &x.Scope)
		case 5:
			(slice_ptr_ast_ImportSpec_codec{}).decode(d, &x.Imports)
		case 6:
			(slice_ptr_ast_Ident_codec{}).decode(d, &x.Unresolved)
		case 7:
			(slice_ptr_ast_CommentGroup_codec{}).decode(d, &x.Comments)
		default:
			d.UnknownField("ast.File", n)
		}
	}
}

func init() {
	codecapi.Register(ast.File{}, ast_File_codec{})
	codecapi.Register(&ast.File{}, ptr_ast_File_codec{})
}

type slice_ast_Decl_codec struct{}

func (slice_ast_Decl_codec) Init() {}

func (c slice_ast_Decl_codec) Encode(e *codecapi.Encoder, x interface{}) { c.encode(e, x.([]ast.Decl)) }

func (c slice_ast_Decl_codec) encode(e *codecapi.Encoder, s []ast.Decl) {
	if s == nil {
		e.EncodeNil()
		return
	}
	e.StartList(len(s))
	for _, x := range s {
		e.EncodeAny(x)
	}
}

func (c slice_ast_Decl_codec) Decode(d *codecapi.Decoder) interface{} {
	var x []ast.Decl
	c.decode(d, &x)
	return x
}

func (c slice_ast_Decl_codec) decode(d *codecapi.Decoder, p *[]ast.Decl) {
	n := d.StartList()
	if n < 0 {
		return
	}
	s := make([]ast.Decl, n)
	for i := 0; i < n; i++ {
		s[i] = d.DecodeAny().(ast.Decl)
	}
	*p = s
}

func init() {
	codecapi.Register([]ast.Decl(nil), slice_ast_Decl_codec{})
}

type slice_ptr_ast_ImportSpec_codec struct{}

func (slice_ptr_ast_ImportSpec_codec) Init() {}

func (c slice_ptr_ast_ImportSpec_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.([]*ast.ImportSpec))
}

func (c slice_ptr_ast_ImportSpec_codec) encode(e *codecapi.Encoder, s []*ast.ImportSpec) {
	if s == nil {
		e.EncodeNil()
		return
	}
	e.StartList(len(s))
	for _, x := range s {
		(ptr_ast_ImportSpec_codec{}).encode(e, x)
	}
}

func (c slice_ptr_ast_ImportSpec_codec) Decode(d *codecapi.Decoder) interface{} {
	var x []*ast.ImportSpec
	c.decode(d, &x)
	return x
}

func (c slice_ptr_ast_ImportSpec_codec) decode(d *codecapi.Decoder, p *[]*ast.ImportSpec) {
	n := d.StartList()
	if n < 0 {
		return
	}
	s := make([]*ast.ImportSpec, n)
	for i := 0; i < n; i++ {
		(ptr_ast_ImportSpec_codec{}).decode(d, &s[i])
	}
	*p = s
}

func init() {
	codecapi.Register([]*ast.ImportSpec(nil), slice_ptr_ast_ImportSpec_codec{})
}

type slice_ptr_ast_CommentGroup_codec struct{}

func (slice_ptr_ast_CommentGroup_codec) Init() {}

func (c slice_ptr_ast_CommentGroup_codec) Encode(e *codecapi.Encoder, x interface{}) {
	c.encode(e, x.([]*ast.CommentGroup))
}

func (c slice_ptr_ast_CommentGroup_codec) encode(e *codecapi.Encoder, s []*ast.CommentGroup) {
	if s == nil {
		e.EncodeNil()
		return
	}
	e.StartList(len(s))
	for _, x := range s {
		(ptr_ast_CommentGroup_codec{}).encode(e, x)
	}
}

func (c slice_ptr_ast_CommentGroup_codec) Decode(d *codecapi.Decoder) interface{} {
	var x []*ast.CommentGroup
	c.decode(d, &x)
	return x
}

func (c slice_ptr_ast_CommentGroup_codec) decode(d *codecapi.Decoder, p *[]*ast.CommentGroup) {
	n := d.StartList()
	if n < 0 {
		return
	}
	s := make([]*ast.CommentGroup, n)
	for i := 0; i < n; i++ {
		(ptr_ast_CommentGroup_codec{}).decode(d, &s[i])
	}
	*p = s
}

func init() {
	codecapi.Register([]*ast.CommentGroup(nil), slice_ptr_ast_CommentGroup_codec{})
}
